/***
	Con la version 7.2 de Postgresql el CALL HANDLER de pgSQL esta incorporado por defecto 
	y no es necesario crearlo.
***/

CREATE FUNCTION plpgsql_call_handler () RETURNS opaque
    AS '/usr/lib/pgsql/plpgsql.so'
    LANGUAGE 'C';

CREATE TRUSTED PROCEDURAL LANGUAGE 'plpgsql'
    HANDLER plpgsql_call_handler
    LANCOMPILER 'PL/pgSQL';


/*** 
   Dado un codigo de cuenta devuelve el identificador
***/

CREATE FUNCTION id_cuenta(varchar) RETURNS int4 AS '
DECLARE
   codcuenta ALIAS FOR $1;
   cta  RECORD;
BEGIN
   SELECT INTO cta idcuenta FROM cuenta  WHERE codigo = "codcuenta";
   IF FOUND THEN
	RETURN cta.idcuenta;
   ELSE
	RETURN 0;
   END IF;
END;
' LANGUAGE 'plpgsql';






/***
   Cuando se inserta un apunte, se aumentan los acumulados.
***/
CREATE FUNCTION aumenta_valor () RETURNS OPAQUE AS '
DECLARE
   cta      int4;
   ccost     int4;
   ctar   RECORD;
   ccostr RECORD;
BEGIN
        UPDATE cuenta SET debe = debe + NEW.debe, haber = haber + NEW.haber WHERE idcuenta = NEW.idcuenta;
        UPDATE c_coste SET debe = debe + NEW.debe, haber = haber + NEW.haber WHERE idc_coste = NEW.idc_coste;
        IF NEW.idcuenta IS NOT NULL THEN
           UPDATE acumulado_canal SET debe= debe + NEW.debe, haber = haber + NEW.haber WHERE idcuenta = NEW.idcuenta AND idcanal = NEW.idcanal;
        END IF;
        cta := NEW.idcuenta;
        ccost := NEW.idc_coste;
        RAISE NOTICE '' Se ha lanzado el trigger cambia_acumulado_c_coste'';
        SELECT INTO ccostr * FROM c_coste WHERE idc_coste = ccost;
        WHILE FOUND LOOP
           SELECT INTO ctar * FROM cuenta WHERE idcuenta = cta;
           WHILE FOUND LOOP
                RAISE NOTICE '' Cuenta % Centro Coste %'', ctar.idcuenta, ccostr.idc_coste;
         	UPDATE acumulado_c_coste SET debe = debe + NEW.debe, haber = haber + NEW.haber WHERE idc_coste = ccostr.idc_coste AND idcuenta = ctar.idcuenta;
	      SELECT INTO ctar * FROM cuenta WHERE idcuenta = ctar.padre;
           END LOOP;
           SELECT INTO ccostr * FROM c_coste WHERE idc_coste = ccostr.padre;
        END LOOP;
        RETURN NEW;
END;
'LANGUAGE 'plpgsql';
CREATE TRIGGER nuevo_apunte AFTER INSERT OR UPDATE on apunte FOR EACH ROW
EXECUTE PROCEDURE aumenta_valor();





/***
   Cuando se borra un apunte, se disminuyen los acumulados.
***/
CREATE FUNCTION disminuye_valor () RETURNS OPAQUE AS '
DECLARE
   cta      int4;
   ccost     int4;
   ctar   RECORD;
   ccostr RECORD;
BEGIN
        UPDATE cuenta SET debe = debe - OLD.debe, haber = haber - OLD.haber WHERE idcuenta = OLD.idcuenta;
        UPDATE c_coste SET debe = debe - OLD.debe, haber = haber - OLD.haber WHERE idc_coste = OLD.idc_coste;
        IF OLD.idcuenta IS NOT NULL THEN
           UPDATE acumulado_canal SET debe= debe - OLD.debe, haber =haber - OLD.haber WHERE idcuenta = OLD.idcuenta AND idcanal = OLD.idcanal;
        END IF;
	cta := OLD.idcuenta;
	ccost := OLD.idc_coste;
	RAISE NOTICE '' Se ha lanzado el trigger cambia_acumulado_c_coste'';
	SELECT INTO ccostr * FROM c_coste WHERE idc_coste = ccost;
	WHILE FOUND LOOP
	   SELECT INTO ctar * FROM cuenta WHERE idcuenta = cta;
	   WHILE FOUND LOOP
	      RAISE NOTICE '' Cuenta % Centro Coste %'', ctar.idcuenta, ccostr.idc_coste;
	      UPDATE acumulado_c_coste SET debe = debe - OLD.debe, haber = haber -OLD.haber WHERE idc_coste = ccostr.idc_coste AND idcuenta = ctar.idcuenta;
	      SELECT INTO ctar * FROM cuenta WHERE idcuenta = ctar.padre;
	    END LOOP;
	    SELECT INTO ccostr * FROM c_coste WHERE idc_coste = ccostr.padre;
	END LOOP;
	RETURN OLD;
END;
'LANGUAGE 'plpgsql';
CREATE TRIGGER nuevo_apunte1 BEFORE DELETE OR UPDATE on apunte FOR EACH ROW
EXECUTE PROCEDURE disminuye_valor();





/***
   Cuando se crea una cuenta se hacen las inserciones necesarias en las tablas de acumulados.
***/
CREATE FUNCTION CreaCuenta () RETURNS OPAQUE AS '
DECLARE
   mrecord RECORD;
BEGIN            
      FOR mrecord IN SELECT * FROM canal LOOP
         INSERT INTO acumulado_canal (idcuenta, idcanal,debe,haber) VALUES(NEW.idcuenta, mrecord.idcanal,0,0);
      END LOOP;
      FOR mrecord IN SELECT * FROM c_coste LOOP
         INSERT INTO acumulado_c_coste (idcuenta, idc_coste,debe,haber) VALUES(NEW.idcuenta, mrecord.idc_coste,0,0);
      END LOOP;
        RETURN NEW;
END;
'LANGUAGE 'plpgsql';
CREATE TRIGGER nueva_cuenta AFTER INSERT on cuenta FOR EACH ROW
EXECUTE PROCEDURE CreaCuenta();





/***
   Cuando se crea un canal se hacen las inserciones oportunas en la tabla de acumulados.
***/
CREATE FUNCTION CreaCanal () RETURNS OPAQUE AS '
DECLARE
   mrecord RECORD;
BEGIN            
      FOR mrecord IN SELECT * FROM cuenta LOOP
         INSERT INTO acumulado_canal (idcuenta, idcanal,debe,haber) VALUES(mrecord.idcuenta, NEW.idcanal,0,0);
      END LOOP;
        RETURN NEW;
END;
'LANGUAGE 'plpgsql';
CREATE TRIGGER nuevo_canal AFTER INSERT on canal FOR EACH ROW
EXECUTE PROCEDURE CreaCanal();




/***
   Cuando se crea un centro de coste se hacen las inserciones correspondientes en la tabla de acumulados
***/
CREATE FUNCTION CreaCCoste () RETURNS OPAQUE AS '
DECLARE
   mrecord RECORD;
BEGIN            
      FOR mrecord IN SELECT * FROM cuenta LOOP
         INSERT INTO acumulado_c_coste (idcuenta, idc_coste,debe,haber) VALUES(mrecord.idcuenta, NEW.idc_coste,0,0);
      END LOOP;
        RETURN NEW;
END;
'LANGUAGE 'plpgsql';
CREATE TRIGGER nuevo_ccoste AFTER INSERT on c_coste FOR EACH ROW
EXECUTE PROCEDURE CreaCCoste();





/***
   Cuando se cambian los valores de una cuenta, se propagan los cambios hacia arriba en el arbol de cuentas
***/
CREATE FUNCTION PropagaAcumuladoCuenta () RETURNS OPAQUE AS '
DECLARE
   incdebe FLOAT8;
   inchaber FLOAT8;
BEGIN
   incdebe = NEW.debe - OLD.debe;
   inchaber = NEW.haber - OLD.haber;
   IF incdebe <> 0 OR inchaber <> 0 THEN
	   UPDATE cuenta SET debe = debe + incdebe, haber = haber + inchaber WHERE idcuenta = OLD.padre;
   END IF;
   RETURN NEW;
END;
' LANGUAGE 'plpgsql';
CREATE TRIGGER propaga_acumulado_cuenta AFTER UPDATE on cuenta FOR EACH ROW
EXECUTE PROCEDURE PropagaAcumuladoCuenta();




/***
   Cuando se modifican los acumulados en un centro de coste se propaga el acumulado a través del arbol de centros de coste.
***/
CREATE FUNCTION PropagaAcumuladoCCoste () RETURNS OPAQUE AS '
DECLARE
   incdebe FLOAT8;
   inchaber FLOAT8;
BEGIN
   incdebe = NEW.debe - OLD.debe;
   inchaber = NEW.haber - OLD.haber;
   IF incdebe <> 0 OR inchaber <> 0 THEN
	   UPDATE c_coste SET debe = debe + incdebe, haber = haber + inchaber WHERE idc_coste = OLD.padre;
   END IF;
   RETURN NEW;
END;
' LANGUAGE 'plpgsql';
CREATE TRIGGER propaga_acumulado_ccoste AFTER UPDATE on c_coste FOR EACH ROW
EXECUTE PROCEDURE PropagaAcumuladoCCoste();





/***
   Cuando se modifica un acumulado de un canal este trigger modifica todos los acumulados de su padre.
***/
CREATE FUNCTION acumulados_canal() RETURNS OPAQUE AS '
DECLARE
   incdebe  FLOAT8;
   inchaber FLOAT8;
   cuentar  RECORD;
BEGIN
   RAISE NOTICE '' Ha entrado el trigger acumulados_canal() '';
   RAISE NOTICE '' idcuenta % idcanal %'', NEW.idcuenta, NEW.idcanal;
   incdebe = NEW.debe - OLD.debe;
   inchaber = NEW.haber - OLD.haber;
   SELECT INTO cuentar * FROM cuenta WHERE idcuenta = NEW.idcuenta;
   SELECT INTO cuentar * FROM cuenta WHERE idcuenta = cuentar.padre;
   IF FOUND THEN
      UPDATE acumulado_canal SET debe = debe + incdebe, haber = haber + inchaber WHERE idcuenta = cuentar.idcuenta AND idcanal = NEW.idcanal;
   END IF;
   RETURN NEW;
END;
' LANGUAGE 'plpgsql';
CREATE TRIGGER acumulados_canal_fk AFTER UPDATE on acumulado_canal FOR EACH ROW
EXECUTE PROCEDURE acumulados_canal();