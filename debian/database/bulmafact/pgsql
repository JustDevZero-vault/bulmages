-- Todos los queries necesarios para crear las bases de datos iniciales de bulmafact 
-- por separado en un solo script, cada uno con nombre y senyal en --#########

SET DATESTYLE TO European;

--Comentado en otra parte para ponerlo aqui arriba por si lo podemos quitar y dejarlo en el psql del admin


-- ahora lo de bulmafact   **************************************************************************

-- bulmafact_schema.sql      
-- ----------------------------------------------------------------------------------------
-- (C)  Joan Miquel Torrer Rigo & Tomeu Borras Riera & Mateu Borras Marco, Agosto 2004
--  joanmi@bulma.net, tborras@conetxia.com mborras@conetxia.com
-- Este documento esta licenciado bajo licencia GPL, el cual no escribimos aqui por pereza.
--  ----------------------------------------------------------------------------------------
--     psql xxxx < bulmafact-0_0_1.sql
--  ---------------------------------------------------------------------------------------

SET SESSION AUTHORIZATION 'postgres';
SET search_path = public, pg_catalog;

SET DATESTYLE TO European;

CREATE FUNCTION plpgsql_call_handler() RETURNS language_handler
    AS '$libdir/plpgsql', 'plpgsql_call_handler'
    LANGUAGE c;
    
--CREATE FUNCTION plpgsql_call_handler() RETURNS language_handler
--    AS '/usr/lib/postgresql/8.0/lib/plpgsql.so', 'plpgsql_call_handler'
--    LANGUAGE c;
    
CREATE TRUSTED PROCEDURAL LANGUAGE plpgsql HANDLER plpgsql_call_handler;


-- NOTACION:
-- Considerar las siguientes opciones de codificaciï¿œ:
-- Los nombres de tabla estan escritos SIEMPRE en singular.
-- Todos los campos de una tabla terminan siempre con el nombre de la tabla (salvo las claves foraneas).
-- Las claves foraneas tienen el mismo nombre que el campo con que se corresponden en la tabla relacionada.
-- En caso de que haya diversas claves foraneas referentes al mismo campo, el criterio es que una de ellas tenga el nombre del campo con el que se corresponde y la otra tenga un nombre significativo.
-- Los campos de clave automatica empiezan por id
-- Los enums se simulan (normalmente) con campos numericos, el significado de los valores debe estar
-- explicado en este archivo.


-- La tabla de configuraciï¿œ.
-- En esta tabla se guardan parametros que el programa va a utilizar.
-- Como por ejemplo el numero de dï¿œitos por defecto de las cuentas o el asiento inteligente que se enlaza con
-- facturacion.
-- Tiene tres campos
-- idconfiguracion: el identificador (No tiene ningn uso especial).
-- nombre: El nombre del parametro de configuracion.
-- valor: El valor que toma dicho parametro.
CREATE TABLE configuracion (
    nombre character varying(25) PRIMARY KEY,
    valor character varying(350)
);


-- Codi: Clau artificial.
-- Descripcio: Nom identificatiu o descripciï¿œbreu.
-- Dies_1T: Dies abans del primer termini computant els blocs de 30 com a mesos naturals.
-- Descompte: Descompte automï¿œic per l's d'aquesta forma de pagament.
CREATE TABLE forma_pago (
   idforma_pago serial PRIMARY KEY,
   descforma_pago character varying(500),
   dias1tforma_pago integer,
   descuentoforma_pago numeric(12,2)
);


-- Codigo: Clave artificial.
-- Nombre: Nombre identificativo del almacï¿œ.
-- diralmacen: Direcciï¿œ del almacï¿œ.
-- poblalmacen: Poblaciï¿œ del almacï¿œ.
-- cpalmacenc: cï¿œigo postal almacï¿œ.
-- telfalmacen: Telï¿œono del almacï¿œ.
-- faxalmacen: Fax del almacï¿œ.
-- emailalmacen: correo electrï¿œico del almacï¿œ.
-- presupuestoautoalmacen el numero de presupuesto es automatico? N=No, 
-- albaranautoalmacen el numero de albaran es automatico? N=No, 
-- facturaautoalmacen el numero de  es automatico? N=No, 
CREATE TABLE almacen (
 idalmacen serial PRIMARY KEY,
 codigoalmacen numeric(5, 0) NOT NULL,
 nomalmacen character varying(50),
 diralmacen character varying(150),
 poblalmacen character varying(50),
 cpalmacen character varying(20),
 telalmacen character varying(20),
 faxalmacen character varying(20),
 emailalmacen character varying(100),
 inactivoalmacen character(1),
 UNIQUE(codigoalmacen)
);


--
-- TOC entry 47 (OID 3090354)
-- Name: staff; Type: TABLE; Schema: public; Owner: fewa
--

CREATE TABLE trabajador (
    idtrabajador serial PRIMARY KEY,
    nomtrabajador character varying NOT NULL,
    apellidostrabajador character varying,
    dirtrabajador character varying,
    nsstrabajador character varying,
    teltrabajador character varying,
    moviltrabajador character varying,
    emailtrabajador character varying,
    fototrabajador character varying,
    activotrabajador boolean DEFAULT TRUE NOT NULL
);


-- Tabla de paï¿œes
-- cod2: cï¿œigo de dos dï¿œitos
-- cod3: cï¿œigo de tres dï¿œitos
-- desc: descripciï¿œ del paï¿œ
CREATE TABLE pais (
   idpais serial PRIMARY KEY,
   cod2pais character varying(2),
   cod3pais character varying(3),
	descpais character varying(50)
);


-- Tabla de monedas
-- cod2: cï¿œigo de dos dï¿œitos
-- cod3: cï¿œigo de tres dï¿œitos
-- desc: descripciï¿œ de la moneda
CREATE TABLE moneda (
   idmoneda serial PRIMARY KEY,
   cod2moneda character varying(2),
   cod3moneda character varying(3),
	descmoneda character varying(50)
);


-- Esta tabla contiene las descripciones de los ivas que se pueden aplicar.
-- Descripcio: Text descriptiu del tipus d'IVA.
CREATE TABLE tipo_iva (
   idtipo_iva serial PRIMARY KEY,
   desctipo_iva character varying(2000)
);

-- Esta tabla contiene las tasas de cada tipo de iva a partir de una fecha dada.
-- porcentasa_iva contiene el porcentaje de la tasa de iva a aplicar.
-- fechatasa_iva es la fecha de entrada en vigor del % de IVA para el tipo descrito.
CREATE TABLE tasa_iva (
	idtasa_iva serial PRIMARY KEY,
	idtipo_iva integer REFERENCES tipo_iva(idtipo_iva) NOT NULL,
	porcentasa_iva NUMERIC(5, 2) NOT NULL,
	fechatasa_iva date NOT NULL,
	UNIQUE (idtipo_iva, fechatasa_iva)
);


-- Tabla con series de Iva, cï¿œigo i descripciï¿œ
-- Bï¿œicamente sirve para garantizar la integridad referencial en las  series de facturaciï¿œ
-- Deberï¿œn existir en contabilidad tambien.
CREATE TABLE serie_factura (
--	idserie_factura serial PRIMARY KEY,
	codigoserie_factura character varying (6) PRIMARY KEY,
	descserie_factura character varying(50) NOT NULL,
	UNIQUE (codigoserie_factura)
);


-- codigofamilia cï¿œigo de la familia.
-- nombrefamilia nombre de la familia
-- descfamilia descripciï¿œ extendida de la familia.
-- codcompfamilia cï¿œigo compuesto de familia: Es la concatenaciï¿œ del cï¿œigo de familia con sus cï¿œigos padres. 
-- codigocompletofamilia Este campo es de sï¿œo lectura, no se puede escribir sobre ï¿œ.

CREATE TABLE familia (
	idfamilia serial PRIMARY KEY,
	codigofamilia character varying(12) NOT NULL,
 	nombrefamilia character varying(50) NOT NULL,
	descfamilia character varying(300),
	padrefamilia integer REFERENCES familia(idfamilia),
	codigocompletofamilia character varying(50) UNIQUE
);

CREATE FUNCTION calculacodigocompletofamilia () RETURNS "trigger"
AS '
DECLARE
	as RECORD;
	codigocompleto character varying(50);
BEGIN
	codigocompleto := NEW.codigofamilia;
	SELECT INTO as codigocompletofamilia FROM familia WHERE idfamilia = NEW.padrefamilia;
	IF FOUND THEN
		codigocompleto := as.codigocompletofamilia || codigocompleto;
	END IF;
        NEW.codigocompletofamilia := codigocompleto;
	RETURN NEW;
END;
' LANGUAGE plpgsql;


CREATE TRIGGER calculacodigocompletofamiliatrigger
    BEFORE INSERT OR UPDATE ON familia
    FOR EACH ROW
    EXECUTE PROCEDURE calculacodigocompletofamilia();
    
    
CREATE FUNCTION propagacodigocompletofamilia () RETURNS "trigger"
AS '
DECLARE
BEGIN
	UPDATE familia SET codigocompletofamilia=codigocompletofamilia WHERE padrefamilia = NEW.idfamilia;
	UPDATE articulo SET codigocompletoarticulo = codigocompletoarticulo WHERE articulo.idfamilia = NEW.idfamilia;
	RETURN NEW;
END;
' LANGUAGE plpgsql;

CREATE TRIGGER propagacodigocompletofamiliatrigger
    AFTER UPDATE ON familia
    FOR EACH ROW
    EXECUTE PROCEDURE propagacodigocompletofamilia();

-- Esta funciï¿œ nos da el identificador de familia dado un cï¿œigo.
--CREATE OR REPLACE FUNCTION idfamilia (text) RETURNS "trigger"
--    AS '
--DECLARE
--    codigo ALIAS FROR $1;
--    mrecord RECORD;
--BEGIN
--    FOR mrecord IN SELECT SUM(baseiva) AS suma, SUM(ivaiva) AS sumaiva FROM iva WHERE iva.idregistroiva=NEW.idregistroiva LOOP
--    	UPDATE registroiva SET baseimp=mrecord.suma, iva=mrecord.sumaiva WHERE idregistroiva=NEW.idregistroiva;
--    END LOOP;
--    RETURN NEW;
--END;
--'    LANGUAGE plpgsql;


-- El tipo de artï¿œulo es una tabla que permite crear una forma alternativa de agrupar los artï¿œulos.
-- codigo: identificador del tipo.
-- desc:
CREATE TABLE tipo_articulo (
	idtipo_articulo serial PRIMARY KEY,
	codtipo_articulo character varying(10),
	desctipo_articulo character varying(50)
);


-- Codigo: Clave artificial.
-- Nombre: Descripciï¿œ corta del artï¿œulo.
-- abrev: Nombre abreviado del articulo (para tpv o cartelitos estanterias...)
-- idtipo_articulo: identificador de tipo de artï¿œulo que se utilizarï¿œpara agrupar artï¿œulos como clasificaciï¿œ alternativa a el surtido (familias).
-- Observaciones: Campo de texto para a comentarios y observaciones.
-- El campo codigocompletoarticulo sï¿œo puede ser de lectura.
CREATE TABLE articulo (
    idarticulo serial PRIMARY KEY,
    codarticulo character varying(12),
    nomarticulo character varying(50),
    abrevarticulo character varying(30),
    obserarticulo character varying(2000),
    presentablearticulo boolean NOT NULL DEFAULT TRUE,
    controlstockarticulo boolean NOT NULL DEFAULT TRUE,
    idtipo_articulo numeric(2, 0) REFERENCES tipo_articulo(idtipo_articulo),
    idtipo_iva integer REFERENCES tipo_iva (idtipo_iva),
    codigocompletoarticulo character varying(100) UNIQUE,
    idfamilia integer REFERENCES familia(idfamilia) NOT NULL,
    stockarticulo numeric(12,2) DEFAULT 0,    
    inactivoarticulo character(1),
    -- ATENCION, este campo no da el pvp real del artï¿œulo, solo es una de las multiples formas de acceder al precio del articulo.
    -- Para obtener el precio de un artï¿œulo se debe usar la funcion pvparticulo.
    -- Para saber el iva correspondiente a un articulo se debe usar la funciï¿œ ivaarticulo.
    pvparticulo numeric(12,2) NOT NULL DEFAULT 0
);



create or replace function is_number(varchar) returns boolean as
'select $1 ~ ''^[-+]?[0-9]+$''' strict immutable language sql;

CREATE OR REPLACE FUNCTION to_number(character varying) RETURNS INT8 AS '
DECLARE
BEGIN
	RAISE NOTICE ''to_number %'', $1;
        RETURN CAST(text($1) AS INT8);
END
' LANGUAGE 'plpgsql';

CREATE OR REPLACE FUNCTION calculacodigocompletoarticulo () RETURNS "trigger"
AS '
DECLARE
	as RECORD;
	codigocompleto character varying(100);
	codnumeric integer;
BEGIN
	-- Lo primero comprobamos el el cÃ³digo del articulo no estÃ© vacio y de ser asÃ­ lo llenamos.
	IF NEW.codarticulo = '''' THEN
		SELECT INTO as max(codarticulo) AS m FROM articulo WHERE idfamilia = NEW.idfamilia;
		IF FOUND THEN
			IF is_number(as.m) THEN
				codnumeric := to_number(as.m);
				codnumeric := codnumeric +1;
				NEW.codarticulo := CAST (codnumeric AS varchar);
				WHILE length(NEW.codarticulo) < 4 LOOP
					NEW.codarticulo := ''0'' || NEW.codarticulo;
				END LOOP;
			ELSE
				NEW.codarticulo := ''0000'';
			END IF;
		ELSE
			NEW.codarticulo = ''0000'';
		END IF;
	END IF;

	codigocompleto := NEW.codarticulo;
	SELECT INTO as codigocompletofamilia FROM familia WHERE idfamilia = NEW.idfamilia;
	IF FOUND THEN
		codigocompleto := as.codigocompletofamilia || codigocompleto;
	END IF;
        NEW.codigocompletoarticulo := codigocompleto;
	RETURN NEW;
END;
' LANGUAGE plpgsql;


CREATE TRIGGER calculacodigocompletoarticulotrigger
    BEFORE INSERT OR UPDATE ON articulo
    FOR EACH ROW
    EXECUTE PROCEDURE calculacodigocompletoarticulo();



    
CREATE OR REPLACE FUNCTION modificadostock () RETURNS "trigger"
AS '
DECLARE 
	cant numeric;
	as RECORD;
BEGIN
	IF NEW.stockarticulo <> OLD.stockarticulo THEN
		cant := NEW.stockarticulo - OLD.stockarticulo;
		FOR as IN SELECT * FROM comparticulo WHERE idarticulo = NEW.idarticulo LOOP
			UPDATE articulo SET stockarticulo = stockarticulo + cant * as.cantcomparticulo WHERE idarticulo = as.idcomponente;
		END LOOP;
	END IF;
	RETURN NEW;
END;
' LANGUAGE plpgsql;

CREATE TRIGGER modificastocktrigger
	AFTER UPDATE ON articulo
	FOR EACH ROW
	EXECUTE PROCEDURE modificadostock();
	
        
-- Componentes de Artï¿œulo
CREATE TABLE comparticulo (
	idarticulo integer NOT NULL REFERENCES articulo(idarticulo),
	cantcomparticulo integer NOT NULL DEFAULT 1,
	idcomponente integer NOT NULL REFERENCES articulo(idarticulo),
	PRIMARY KEY (idarticulo, idcomponente)
);


-- Los proveedores son los que nos suminstran articulos y/o servicios.
-- COMPROVACIONS D'INTEGRITAT>Genï¿œiques:
-- 1 Article tï¿œ1 sol proveï¿œor principal.
-- 1 Article tï¿œ1 sol proveï¿œor referent.
-- CAMPOS
-- ======
-- Codi: Clau artificial.
-- Nom: Nom comercial o fiscal.
-- Nom_alternatiu: Nom comercial o fiscal.
-- CIF: Codi d'Identificaciï¿œFiscal.
-- CodiCli: Codi de client amb que ens facturen. ï¿œil per a identificar-nos.
-- C_Banc
-- Comentaris
-- Adreï¿œ: Adreï¿œ.
-- Poblaciï¿œ Poblaciï¿œ
-- CProv: Codi de provincia (dos primers dï¿œits del codi postal).
-- sCP: Tres darrers dï¿œits del codi postal.
-- Telf: Telï¿œon.
-- Fax: Fax.
-- Email: eMail.
-- Url: Url.
-- CompteWeb: Dades de login si disposen de tenda o tarifes en lï¿œia
CREATE TABLE proveedor (
   idproveedor serial PRIMARY KEY,
   nomproveedor character varying(200),
   nomaltproveedor character varying(200),
   cifproveedor character varying(12) UNIQUE,
   codicliproveedor character varying(30),
   cbancproveedor character varying(20),
   comentproveedor character varying(2000),
   dirproveedor character varying(50),
   poblproveedor character varying(50),
   cpproveedor character varying(9) NOT NULL,
   telproveedor character varying(12),
   faxproveedor character varying(12),
   emailproveedor character varying(100),
   urlproveedor character varying(100),
   clavewebproveedor character varying(100),
   inactivoproveedor character(1)
);


--Numero: Nmero de divisiï¿œ(clau artificial).
--Descripcio: Nom o descripciï¿œde la divisiï¿œ
--Contactes: Nom de persona o persones de contacte.
--Comentaris
--Telf: Telï¿œon.
--Fax: Fax.
--Email
CREATE TABLE division (
   iddivision serial PRIMARY KEY,
   descdivision character varying(1000),
   contactosdivisioon character varying(500),
   comentdivision character varying(2000),
   teldivision character varying(20),
   faxdivision character varying(20),
   maildivision character varying(100),
   idproveedor integer NOT NULL REFERENCES proveedor(idproveedor),
   inactivodivision character(1)
);


-- El cliente siempre tiene la razï¿œ, bueno, o por lo menos eso cree.
--Codi: Clau artificial.
--Nom: Nom comercial o fiscal.
--Nom_alternatiu: Nom comercial o fiscal.
--CIF: Codi d'Identificaciï¿œFiscal.
--C_Banc: Compte Bancari.
--Adr: Adreï¿œ.
--Pobl: Poblaciï¿œ
--CProv: Codi de provincia (dos primers dï¿œits del codi postal).
--sCP: Tres darrers dï¿œits del codi postal.
--Telf: Telï¿œon.
--Fax: Fax.
--Email: eMail.
--Url: Url.
--Data_alta
--Data_Baixa
---Comentaris
CREATE TABLE cliente (
   idcliente serial PRIMARY KEY,
   nomcliente character varying(100),
   nomaltcliente character varying(300),
   cifcliente character varying(200) UNIQUE,
   bancocliente character varying(35),
   dircliente character varying(100),
   poblcliente character varying(40),
   cpcliente character varying(10),
   telcliente character varying(20),
   faxcliente character varying(20),
   mailcliente character varying(100),
   urlcliente character varying(150),
   faltacliente date DEFAULT NOW(),
   fbajacliente date,
   comentcliente character varying(2000),
   inactivocliente character(1),
   provcliente character varying
);


CREATE TABLE cobro (
   idcobro serial PRIMARY KEY,
   idcliente integer NOT NULL REFERENCES cliente(idcliente),
   fechacobro date DEFAULT NOW(),
   cantcobro numeric(12,2) DEFAULT 0,
   refcobro character varying(12) NOT NULL,
   previsioncobro boolean DEFAULT FALSE,
   comentcobro character varying(500),
   idtrabajador integer REFERENCES trabajador(idtrabajador)
);
   

CREATE TABLE pago (
   idpago serial PRIMARY KEY,
   idproveedor integer NOT NULL REFERENCES proveedor(idproveedor),
   fechapago date DEFAULT NOW(),
   cantpago numeric(12,2) DEFAULT 0,
   refpago character varying(12) NOT NULL,
   previsionpago boolean DEFAULT FALSE,
   comentpago character varying(500),
   idtrabajador integer REFERENCES trabajador(idtrabajador)   
);

-- Any: Any en que s'efectua la comanda.
-- Numero: Nmero de comanda (comenï¿œnt de 1 cada any).
-- Descripcio: Breu descripciï¿œo comentari opcional.
-- Data: Data d'emisiï¿œde la comanda.
CREATE TABLE pedido (
   idpedido serial PRIMARY KEY,
   numpedido character varying(60),
   fechapedido date,
   descpedido character varying(500),
   iddivision integer NOT NULL REFERENCES division(iddivision),
   idalmacen integer NOT NULL REFERENCES almacen(idalmacen),
   idtrabajador integer REFERENCES trabajador(idtrabajador)   
);



CREATE TABLE usuario (
    loginusuario character varying(15) PRIMARY KEY,
    nombreusuario character varying(35),
    apellido1usuario character varying(35),
    apellido2usuario character varying(35),
    claveusuario character varying(35),
    permisosusuario text
);



-- Any: Any de facturaciï¿œ
-- Numero: Nmero de factura.
-- Data Comentaris
-- Factura de proveï¿œor.
CREATE TABLE fra_pro (
   idfra_pro serial PRIMARY KEY,
   numfra_pro character varying(60),
   fcrefra_pro date,
   comentfra_pro character varying(2000)
);



-- Albaran de proveedor
-- Any: Any en que s'efectua la comanda.
-- NumCompra: Numero de Compra (Clau artificial per poder registrar recepcions que ens arribin sense l'albarï¿œpostposant la cumplimentaciï¿œdel nmero d'albarï¿œ.
-- NumAlbara: Nmero d'albarï¿œ
-- Data: Data de l'albarï¿œ-- Recepcio: Data de recepciï¿œ
-- Comentaris
CREATE TABLE alb_pro (
   idalb_pro serial PRIMARY KEY,
   ncompraalb_pro integer,
   nalbalb_pro character varying(60),
   fcrealb_pro date,
   frecepalb_pro date,
   comentalb_pro character varying(2000),

   idfra_pro integer REFERENCES fra_pro(idfra_pro),
   idalmacen integer NOT NULL REFERENCES almacen(idalmacen)
);



-- Linea de pedido
-- Numero: Nmero de lï¿œia.
-- Descripcio: Descripcio de l'article.
-- Quantitat
-- PVD
-- Previsiï¿œ Data prevista de recepciï¿œ

CREATE TABLE lpedido (
   numlpedido serial PRIMARY KEY,
   desclpedido character varying(150),
   cantlpedido numeric(12,2),
   pvdlpedido numeric(12,2),
   prevlpedido date,
   ivalpedido numeric(12,2),
   descuentolpedido numeric(12,2),
   idpedido integer NOT NULL REFERENCES pedido(idpedido),
   idalb_pro integer REFERENCES alb_pro(idalb_pro),
   idarticulo integer REFERENCES articulo(idarticulo)
--      PRIMARY KEY(idpedido, numlpedido)
);




-- Entendemos que un presupuesto es una relaciï¿œ de materiales y trabajos cuantificada que
-- hacemos a peticiï¿œ de un cliente determinado
-- Numero
-- Data: Data d'emisiï¿œdel presupost.
-- PersContacte: Nom de persona de contacte (si cal).
-- TelfContacte: Telï¿œon.
-- Venciment: Data mï¿œima de validesa del presupost.
-- Comentaris
--  Pressupost a clients.
CREATE TABLE presupuesto (
   idpresupuesto serial PRIMARY KEY,
   numpresupuesto integer NOT NULL UNIQUE,
   refpresupuesto character varying(12) NOT NULL,
   fpresupuesto date,
   descpresupuesto character varying(150),
   contactpresupuesto character varying(90),
   telpresupuesto character varying(20),
   vencpresupuesto date,
   comentpresupuesto character varying(3000),
   idusuari integer,
   procesadopresupuesto boolean DEFAULT FALSE,
   idcliente integer REFERENCES cliente(idcliente),
   idalmacen integer NOT NULL REFERENCES almacen(idalmacen),
   idforma_pago integer NOT NULL REFERENCES forma_pago(idforma_pago),
   idtrabajador integer REFERENCES trabajador(idtrabajador),   
   UNIQUE (idalmacen, numpresupuesto)
);

CREATE FUNCTION restriccionespresupuesto () RETURNS "trigger"
AS '
DECLARE
asd RECORD;
BEGIN
        IF NEW.numpresupuesto IS NULL THEN
                SELECT INTO asd max(numpresupuesto) AS m FROM presupuesto;
		IF asd.m IS NOT NULL THEN	
			NEW.numpresupuesto := asd.m + 1;
		ELSE

			NEW.numpresupuesto := 1;
		END IF;			
        END IF;
	IF NEW.refpresupuesto IS NULL OR NEW.refpresupuesto = '''' THEN
		SELECT INTO asd crearef() AS m;
		IF FOUND THEN
			NEW.refpresupuesto := asd.m;
		END IF;
	END IF;
        RETURN NEW;
END;
' LANGUAGE plpgsql;


CREATE TRIGGER restriccionespresupuestotrigger
    BEFORE INSERT OR UPDATE ON presupuesto
    FOR EACH ROW
    EXECUTE PROCEDURE restriccionespresupuesto();


-- Descuento de presupuesto.
-- Numero
--Concepte: Descripciï¿œdel motiu de descompte.
--Proporcio: Percentatge a descomptar.
-- Descompte de pressupost a clients.
CREATE TABLE dpresupuesto (
   iddpresupuesto serial PRIMARY KEY,
   conceptdpresupuesto character varying(2000),
   proporciondpresupuesto numeric(12,2),
   idpresupuesto integer REFERENCES presupuesto(idpresupuesto)
   -- Falta poner el lugar donde se aplica el descuento, antes de la factura o despuï¿œ de ï¿œta.
);



-- Linea de presupuesto
-- Numero
-- Descripcio: Descripciï¿œde l'article en el moment de ser presupostat.
-- Quantitat
-- PVP: Preu de l'article en el moment de ser pressupostat
-- Descompte: Percentatge de descompte en lï¿œia.
-- Linia de pressupost a clients.
CREATE TABLE lpresupuesto (
   idlpresupuesto serial PRIMARY KEY,
   desclpresupuesto character varying(150),
   cantlpresupuesto numeric(12,2),
   pvplpresupuesto numeric(12,2),
   ivalpresupuesto numeric(12,2),
   descuentolpresupuesto numeric(12,2),
   idpresupuesto integer NOT NULL REFERENCES presupuesto(idpresupuesto),
   idarticulo integer REFERENCES articulo(idarticulo)
);

-- Falta poner por defecto el pvp y el iva


-- Any: Any en que s'efectua la comanda.
-- Numero: Nmero de comanda (comenï¿œnt de 1 cada any).
-- Descripcio: Breu descripciï¿œo comentari opcional.
-- Data: Data d'emisiï¿œde la comanda.
CREATE TABLE pedidocliente (
   idpedidocliente serial PRIMARY KEY,
   numpedidocliente integer UNIQUE NOT NULL,
   fechapedidocliente date,
   refpedidocliente character varying(12) NOT NULL,   
   descpedidocliente character varying(500),
   comentpedidocliente character varying(3000),
   contactpedidocliente character varying(90),
   telpedidocliente character varying(20),
   idusuari integer,
   idpresupuesto integer REFERENCES presupuesto(idpresupuesto),
   procesadopedidocliente boolean DEFAULT FALSE,   
   idcliente integer NOT NULL REFERENCES cliente(idcliente),
   idforma_pago integer REFERENCES forma_pago(idforma_pago),
   idalmacen integer NOT NULL REFERENCES almacen(idalmacen),
   idtrabajador integer REFERENCES trabajador(idtrabajador)
);

CREATE FUNCTION restriccionespedidocliente () RETURNS "trigger"
AS '
DECLARE
asd RECORD;
BEGIN
        IF NEW.numpedidocliente IS NULL THEN
                SELECT INTO asd max(numpedidocliente) AS m FROM pedidocliente;
		IF asd.m IS NOT NULL THEN
			NEW.numpedidocliente := asd.m + 1;
		ELSE
			NEW.numpedidocliente := 1;
		END IF;
        END IF;
	IF NEW.refpedidocliente IS NULL OR NEW.refpedidocliente = '''' THEN
		SELECT INTO asd crearef() AS m;
		IF FOUND THEN
			NEW.refpedidocliente := asd.m;
		END IF;
	END IF;
        RETURN NEW;
END;
' LANGUAGE plpgsql;


CREATE TRIGGER restriccionespedidoclientetrigger
    BEFORE INSERT OR UPDATE ON pedidocliente
    FOR EACH ROW
    EXECUTE PROCEDURE restriccionespedidocliente();


-- Descuento de pedidocliente.
-- Numero
--Concepte: Descripciï¿œdel motiu de descompte.
--Proporcio: Percentatge a descomptar.
-- Descompte de pressupost a clients.
CREATE TABLE dpedidocliente (
   iddpedidocliente serial PRIMARY KEY,
   conceptdpedidocliente character varying(2000),
   proporciondpedidocliente numeric(12,2),
   idpedidocliente integer NOT NULL REFERENCES pedidocliente(idpedidocliente)
   -- Falta poner el lugar donde se aplica el descuento, antes de la factura o despuï¿œ de ï¿œta.
);    
    
-- Linea de pedido
-- Numero: Nmero de lï¿œia.
-- Descripcio: Descripcio de l'article.
-- Quantitat
-- PVD
-- Previsiï¿œ Data prevista de recepciï¿œ
CREATE TABLE lpedidocliente (
   numlpedidocliente serial PRIMARY KEY,
   desclpedidocliente character varying(150),
   cantlpedidocliente numeric(12,2),
   pvplpedidocliente numeric(12,2),
   prevlpedidocliente date,
   ivalpedidocliente numeric(12,2),
   descuentolpedidocliente numeric(12,2),   
   idpedidocliente integer NOT NULL REFERENCES pedidocliente(idpedidocliente),
   puntlpedidocliente boolean DEFAULT FALSE,
   idarticulo integer REFERENCES articulo(idarticulo)
);




-- FACTURACIO>Albarans:
-- Albarans pendents: S'entendran com albarans pendents tots aquells dels quals no existeixi ticket, factura ni nofactura.
-- Numero
-- Data
-- Factura a clients.
CREATE TABLE factura (
   idfactura serial PRIMARY KEY,
   codigoserie_factura character varying (6) NOT NULL REFERENCES serie_factura(codigoserie_factura),
   numfactura integer NOT NULL,
   reffactura character varying(15) NOT NULL,
   ffactura date,
   descfactura character varying(500),   
   idalmacen integer NOT NULL REFERENCES almacen(idalmacen),
   contactfactura character varying(90),
   telfactura character varying(20),
   comentfactura character varying(3000),
   procesadafactura boolean DEFAULT FALSE, 
   idusuari integer,
   idcliente integer REFERENCES cliente(idcliente),
   idforma_pago integer REFERENCES forma_pago(idforma_pago),   
   UNIQUE (idalmacen, codigoserie_factura, numfactura),
   idtrabajador integer REFERENCES trabajador(idtrabajador)
);

CREATE FUNCTION restriccionesfactura () RETURNS "trigger"
AS '
DECLARE
asd RECORD;
BEGIN
        IF NEW.numfactura IS NULL THEN
                SELECT INTO asd max(numfactura) AS m FROM factura WHERE idserie_factura=NEW.idserie_factura AND idalmacen = NEW.idalmacen;
		IF asd.m IS NOT NULL THEN
			NEW.numfactura := asd.m + 1;
		ELSE
			NEW.numfactura := 1;
		END IF;
        END IF;
	IF NEW.reffactura IS NULL OR NEW.reffactura = '''' THEN
		SELECT INTO asd crearef() AS m;
		IF FOUND THEN
			NEW.reffactura := asd.m;
		END IF;
	END IF;
        RETURN NEW;
END;
' LANGUAGE plpgsql;


CREATE TRIGGER restriccionesfacturatrigger
    BEFORE INSERT OR UPDATE ON factura
    FOR EACH ROW
    EXECUTE PROCEDURE restriccionesfactura();

    
-- Descuento de pedidocliente.
-- Numero
--Concepte: Descripciï¿œdel motiu de descompte.
--Proporcio: Percentatge a descomptar.
-- Descompte de pressupost a clients.
CREATE TABLE dfactura (
   iddfactura serial PRIMARY KEY,
   conceptdfactura character varying(2000),
   proporciondfactura numeric(12,2),
   idfactura integer NOT NULL REFERENCES factura(idfactura)
   -- Falta poner el lugar donde se aplica el descuento, antes de la factura o despuï¿œ de ï¿œta.
); 
    

-- Linea de presupuesto
-- Numero
-- Descripcio: Descripciï¿œde l'article en el moment de ser presupostat.
-- Quantitat
-- PVP: Preu de l'article en el moment de ser pressupostat
-- Descompte: Percentatge de descompte en lï¿œia.
-- Linia de pressupost a clients.
CREATE TABLE lfactura (
   idlfactura serial PRIMARY KEY,
   desclfactura character varying(150),
   cantlfactura numeric(12,2),
   pvplfactura numeric(12,2),
   ivalfactura numeric(12,2),
   descuentolfactura numeric(12,2),
   idfactura integer NOT NULL REFERENCES factura(idfactura),
   idarticulo integer REFERENCES articulo(idarticulo)
);


-- -------------------------------------------------------------------------------------------
-- FACTURACIO>Albarans:
-- Albarans pendents: S'entendran com albarans pendents tots aquells dels quals no existeixi ticket, factura ni nofactura.
-- Numero
-- Data
-- Factura a clients.
CREATE TABLE facturap (
   idfacturap serial PRIMARY KEY,
   numfacturap character varying (20) NOT NULL UNIQUE,
   reffacturap character varying(15) NOT NULL,
   ffacturap date,
   descfacturap character varying(500),   
   contactfacturap character varying(90),
   telfacturap character varying(20),
   comentfacturap character varying(3000),
   procesadafacturap boolean DEFAULT FALSE, 
   idusuari integer,
   idproveedor integer REFERENCES proveedor(idproveedor),
   idforma_pago integer REFERENCES forma_pago(idforma_pago),
   idtrabajador integer REFERENCES trabajador(idtrabajador)   
);

CREATE FUNCTION restriccionesfacturap () RETURNS "trigger"
AS '
DECLARE
asd RECORD;
BEGIN
	IF NEW.reffacturap IS NULL OR NEW.reffacturap = '''' THEN
		SELECT INTO asd crearef() AS m;
		IF FOUND THEN
			NEW.reffacturap := asd.m;
		END IF;
	END IF;
        RETURN NEW;
END;
' LANGUAGE plpgsql;


CREATE TRIGGER restriccionesfacturaptrigger
    BEFORE INSERT OR UPDATE ON facturap
    FOR EACH ROW
    EXECUTE PROCEDURE restriccionesfacturap();


-- Linea de presupuesto
-- Numero
-- Descripcio: Descripciï¿œde l'article en el moment de ser presupostat.
-- Quantitat
-- PVP: Preu de l'article en el moment de ser pressupostat
-- Descompte: Percentatge de descompte en lï¿œia.
-- Linia de pressupost a clients.
CREATE TABLE lfacturap (
   idlfacturap serial PRIMARY KEY,
   desclfacturap character varying(150),
   cantlfacturap numeric(12,2),
   pvplfacturap numeric(12,2),
   ivalfacturap numeric(12,2),
   descuentolfacturap numeric(12,2),
   idfacturap integer NOT NULL REFERENCES facturap(idfacturap),
   idarticulo integer REFERENCES articulo(idarticulo)
);



-- Descuento de factura proveedor
-- Numero
--Concepte: Descripciï¿œdel motiu de descompte.
--Proporcio: Percentatge a descomptar.
-- Descompte de pressupost a clients.
CREATE TABLE dfacturap (
   iddfacturap serial PRIMARY KEY,
   conceptdfacturap character varying(2000),
   proporciondfacturap numeric(12,2),
   idfacturap integer NOT NULL REFERENCES factura(idfactura)
   -- Falta poner el lugar donde se aplica el descuento, antes de la factura o despuï¿œ de ï¿œta.
); 

-- -------------------------------------------------------------------------------------------

-- FACTURACIO>Albarans:
-- Albarans pendents: S'entendran com albarans pendents tots aquells dels quals no existeixi ticket, factura ni nofactura.
-- Numero: Numero de nofactura
-- Data
-- Concepte: Descripcio del concepte pel qual no es poden facturar els albarans aqui agrupats (garantia, -- contracte de manteniment, regals a clients, etc...).
-- Observacions
-- Agrupacio d'albarans no facturables en funciï¿œd'un determinat concepte.
CREATE TABLE nofactura (
	idnofactura serial PRIMARY KEY,
   numnofactura integer NOT NULL,
   fechanofactura date,
   conceptnofactura character varying(150),
   observnofactura character varying(150),
	idalmacen integer NOT NULL REFERENCES almacen(idalmacen),
	UNIQUE (idalmacen, numnofactura)
);



-- COMPROVACIONS D'INTEGRITAT>Genï¿œiques:
-- Tots els albarans d'una factura corresponen al mateix client.
-- FACTURACIO>Albarans:
-- Albarans pendents: S'entendran com albarans pendents tots aquells dels quals no existeixi ticket, factura ni nofactura.
-- Numero
-- Data
-- Albarï¿œa clients.
CREATE TABLE albaranp (
   idalbaranp serial PRIMARY KEY,
   numalbaranp integer NOT NULL UNIQUE,
   descalbaranp character varying(150),
   refalbaranp character varying(12) NOT NULL,
   fechaalbaranp date DEFAULT now(),
--   loginusuario character varying(15) REFERENCES usuario(loginusuario),
   comentalbaranp character varying(3000),
   procesadoalbaranp boolean DEFAULT FALSE,
   idproveedor integer REFERENCES proveedor(idproveedor),
   idforma_pago integer REFERENCES forma_pago(idforma_pago),
   idusuari integer,
--   idfactura integer REFERENCES factura(idfactura),
--   idnofactura integer REFERENCES nofactura(idnofactura),
   idalmacen integer NOT NULL REFERENCES almacen(idalmacen),
   idtrabajador integer REFERENCES trabajador(idtrabajador),   
   UNIQUE (idalmacen, numalbaranp)
);

CREATE FUNCTION restriccionesalbaranp () RETURNS "trigger"
AS '
DECLARE
asd RECORD;
BEGIN
        IF NEW.numalbaranp IS NULL THEN
                SELECT INTO asd max(numalbaranp) AS m FROM albaranp;
		IF asd.m IS NOT NULL THEN
			NEW.numalbaranp := asd.m + 1;
		ELSE
			NEW.numalbaranp := 1;
		END IF;
        END IF;
	IF NEW.refalbaranp IS NULL OR NEW.refalbaranp = '''' THEN
		SELECT INTO asd crearef() AS m;
		IF FOUND THEN
			NEW.refalbaranp := asd.m;
		END IF;
	END IF;
        RETURN NEW;
END;
' LANGUAGE plpgsql;


CREATE TRIGGER restriccionesalbaranptrigger
    BEFORE INSERT OR UPDATE ON albaranp
    FOR EACH ROW
    EXECUTE PROCEDURE restriccionesalbaranp();


-- Numero
-- Descripcio
-- Quantitat
-- PVP: Preu de l'article en el moment de la compra o de ser presupostat.
-- Descompte
-- Lï¿œia d'albarï¿œa clients.
CREATE TABLE lalbaranp (
   numlalbaranp serial PRIMARY KEY,
   desclalbaranp character varying(100),
   cantlalbaranp numeric(12,2),
   ivalalbaranp numeric(12,2),
   pvplalbaranp numeric(12,2),
   descontlalbaranp numeric(12,2),
   idalbaranp integer NOT NULL REFERENCES albaranp(idalbaranp),
   idarticulo integer NOT NULL REFERENCES articulo(idarticulo)
);

CREATE FUNCTION disminuyestockp () RETURNS "trigger"
AS '
DECLARE
BEGIN
	UPDATE articulo SET stockarticulo = stockarticulo - OLD.cantlalbaranp WHERE idarticulo= OLD.idarticulo;
	RETURN OLD;
END;
' LANGUAGE plpgsql;


CREATE TRIGGER disminuyestockpt
    AFTER DELETE OR UPDATE ON lalbaranp
    FOR EACH ROW
    EXECUTE PROCEDURE disminuyestockp();


CREATE FUNCTION aumentastockp () RETURNS "trigger"
AS '
DECLARE
BEGIN
	UPDATE articulo SET stockarticulo = stockarticulo + NEW.cantlalbaranp WHERE idarticulo = NEW.idarticulo;
	RETURN NEW;
END;
' LANGUAGE plpgsql;


CREATE TRIGGER aumentastockpt
    AFTER INSERT OR UPDATE ON lalbaranp
    FOR EACH ROW
    EXECUTE PROCEDURE aumentastockp(); 


-- Descuento albaran proveedor
-- Numero
-- Concepte: Descripciï¿œdel motiu de descompte.
-- Proporcio: Percentatge a descomptar.
-- Descompte d'albarï¿œa clients.
CREATE TABLE dalbaranp (
   iddalbaranp serial PRIMARY KEY,
   conceptdalbaranp character varying(500),
   proporciondalbaranp numeric(12,2),
   idalbaranp integer NOT NULL REFERENCES albaranp(idalbaranp)
);




-- COMPROVACIONS D'INTEGRITAT>Genï¿œiques:
-- Tots els albarans d'una factura corresponen al mateix client.
-- FACTURACIO>Albarans:
-- Albarans pendents: S'entendran com albarans pendents tots aquells dels quals no existeixi ticket, factura ni nofactura.
-- Numero
-- Data
-- Albarï¿œa clients.
CREATE TABLE albaran (
   idalbaran serial PRIMARY KEY,
   numalbaran integer NOT NULL UNIQUE,
   descalbaran character varying(150),
   refalbaran character varying(12) NOT NULL,
   fechaalbaran date,
--   loginusuario character varying(15) REFERENCES usuario(loginusuario),
   comentalbaran character varying(3000),
   comentprivalbaran character varying(3000),
   procesadoalbaran boolean DEFAULT FALSE,
   contactalbaran character varying,
   telalbaran character varying,
   idusuari integer,
   idcliente integer REFERENCES cliente(idcliente),
   idforma_pago integer REFERENCES forma_pago(idforma_pago),
   idfactura integer REFERENCES factura(idfactura),
   idnofactura integer REFERENCES nofactura(idnofactura),
   idalmacen integer NOT NULL REFERENCES almacen(idalmacen),
   idtrabajador integer REFERENCES trabajador(idtrabajador),   
   UNIQUE (idalmacen, numalbaran)
);

-- **********************************************************************
-- APARTADO DE COMPROBACIONES DE INTEGRIDAD EXTRA Y DETECCIï¿œ DE ERRORES.
-- **********************************************************************
-- **********************************************************************
CREATE FUNCTION restriccionesalbaran () RETURNS "trigger"
AS '
DECLARE
asd RECORD;
BEGIN
        IF NEW.numalbaran IS NULL THEN
                SELECT INTO asd max(numalbaran) AS m FROM albaran;
		IF asd.m IS NOT NULL THEN
			NEW.numalbaran := asd.m + 1;
		ELSE
			NEW.numalbaran := 1;
		END IF;
        END IF;
	IF NEW.refalbaran IS NULL OR NEW.refalbaran = '''' THEN
		SELECT INTO asd crearef() AS m;
		IF FOUND THEN
			NEW.refalbaran := asd.m;
		END IF;
	END IF;
        RETURN NEW;
END;
' LANGUAGE plpgsql;


CREATE TRIGGER restriccionesalbarantrigger
    BEFORE INSERT OR UPDATE ON albaran
    FOR EACH ROW
    EXECUTE PROCEDURE restriccionesalbaran();

    
CREATE FUNCTION random_string(int4) RETURNS "varchar" AS '
DECLARE
iLoop int4;
result varchar;
BEGIN
result = '''';
IF ($1>0) AND ($1 < 255) THEN
  FOR iLoop in 1 .. $1 LOOP
    result = result || chr(int4(random()*26)+65);
  END LOOP;
  RETURN result;
ELSE
  RETURN ''f'';
END IF;
END;
'  LANGUAGE 'plpgsql';
    

CREATE FUNCTION crearef () RETURNS character varying (15)
AS '
DECLARE
asd RECORD;
result character varying(15);
efound boolean;
BEGIN
	efound := FALSE;
	WHILE efound = FALSE LOOP
		result := random_string(6);
		efound := TRUE;
		SELECT INTO asd idpresupuesto FROM presupuesto WHERE refpresupuesto=result;
		IF FOUND THEN
			efound := FALSE;
		END IF;
		SELECT  INTO asd idpedidocliente FROM pedidocliente WHERE refpedidocliente=result;
		IF FOUND THEN
			efound := FALSE;
		END IF;
		SELECT  INTO asd idalbaran FROM albaran WHERE refalbaran=result;
		IF FOUND THEN
			efound := FALSE;
		END IF;	
		SELECT INTO asd  idfactura FROM factura WHERE reffactura=result;
		IF FOUND THEN
			efound := FALSE;
		END IF;	
	END LOOP;
	RETURN result;
END;
' LANGUAGE plpgsql;

-- Descuento albaran
-- Numero
-- Concepte: Descripciï¿œdel motiu de descompte.
-- Proporcio: Percentatge a descomptar.
-- Descompte d'albarï¿œa clients.
CREATE TABLE dalbaran (
   iddalbaran serial PRIMARY KEY,
   conceptdalbaran character varying(500),
   proporciondalbaran numeric(12,2),
   idalbaran integer NOT NULL REFERENCES albaran(idalbaran)
);


-- Numero
-- Descripcio
-- Quantitat
-- PVP: Preu de l'article en el moment de la compra o de ser presupostat.
-- Descompte
-- Lï¿œia d'albarï¿œa clients.
CREATE TABLE lalbaran (
   numlalbaran serial PRIMARY KEY,
   desclalbaran character varying(100),
   cantlalbaran numeric(12,2),
   pvplalbaran numeric(12,2),
   descontlalbaran numeric(12,2),
   ivalalbaran numeric(12,2),
   idalbaran integer NOT NULL REFERENCES albaran(idalbaran),
   idarticulo integer NOT NULL REFERENCES articulo(idarticulo)
);
CREATE FUNCTION disminuyestock () RETURNS "trigger"
AS '
DECLARE
BEGIN
	UPDATE articulo SET stockarticulo = stockarticulo + OLD.cantlalbaran WHERE idarticulo= OLD.idarticulo;
	RETURN OLD;
END;
' LANGUAGE plpgsql;


CREATE TRIGGER disminuyestockt
    AFTER DELETE OR UPDATE ON lalbaran
    FOR EACH ROW
    EXECUTE PROCEDURE disminuyestock();


CREATE FUNCTION aumentastock () RETURNS "trigger"
AS '
DECLARE
BEGIN
	UPDATE articulo SET stockarticulo = stockarticulo - NEW.cantlalbaran WHERE idarticulo = NEW.idarticulo;
	RETURN NEW;
END;
' LANGUAGE plpgsql;


CREATE TRIGGER aumentastockt
    AFTER INSERT OR UPDATE ON lalbaran
    FOR EACH ROW
    EXECUTE PROCEDURE aumentastock();    
    
    
-- FACTURACIO>Albarans:
-- Albarans pendents: S'entendran com albarans pendents tots aquells dels quals no existeixi ticket, factura ni nofactura.
CREATE TABLE ticket (
   numticket integer PRIMARY KEY,
   fechaticket date
);


-- COMPROVACIONS D'INTEGRITAT>Genï¿œiques:
-- 1 Article tï¿œ1 sol proveï¿œor principal.
-- 1 Article tï¿œ1 sol proveï¿œor referent.
CREATE TABLE suministra (
   idsuministra serial PRIMARY KEY,
   refpro character varying(100),
   principalsuministra numeric(12,2),
   idproveedor integer REFERENCES proveedor(idproveedor),
   idarticulo integer REFERENCES articulo(idarticulo)
);






-- Los tipos de tarifa permiten tener diferentes precios para un mismo artï¿œulo en funciï¿œ de alguna variable que queramos definir (para un cliente, para una zona, si es para un minorista, tienda propia franquiciada ...
-- codigo: es un identificador pnemotï¿œnico de la tarifa.
-- desc: es un texto descriptivo del tipo de tarifa.

CREATE TABLE tipo_tarifa ( 
	idtipo_tarifa serial PRIMARY KEY,
	codtipo_tarifa character varying(10) NOT NULL UNIQUE,
	desctipo_tarifa character varying(50)
);


-- La tabla tarifa contiene los precios de venta y oferta incluidas las ofertas MxN.
-- idalmacen: Almacï¿œ o tienda a la que corresponden los precios.
-- idarticulo: idetificador del articulo al que corresponde el precio.
-- finicio: fecha de inicio vigencia del precio
-- ffin: fecha de finalizaciï¿œ de vigencia del precio.
-- esoferta: indica si el precio es de oferta.
-- esmxn: indica si la oferta es mxn (p.e. 3x2).
-- cantidadm: cantidad de unidades para primer valor en oferta mxn (valor de unidades llevadas).
-- cantidadn: cantidad de unidades para segundo valor en oferta mxn (valor de unidades pagadas).
-- FALTA DEFINIR LAS REGLAS PARA EVITAR SOLAPAMIENTOS ENTRE OFERTAS.

CREATE TABLE tarifa (
	idtarifa serial PRIMARY KEY,
   idalmacen integer NOT NULL REFERENCES almacen(idalmacen),
	idarticulo integer NOT NULL REFERENCES articulo(idarticulo),
	idtipo_tarifa integer NOT NULL REFERENCES tipo_tarifa(idtipo_tarifa),
	finiciotarifa date,
	ffintarifa date,
	preciotarifa numeric(13, 4),
	esofertatarifa character(1) NOT NULL CHECK(esofertatarifa='S' OR esofertatarifa='N'),
	esmxntarifa character(1),
	cantidadmtarifa numeric(5, 0),
	cantidadntarifa numeric(5, 0)	
);


-- Restricciones para la tabla tarifa:
-- Para un mismo almacï¿œ, artï¿œulo y tarifa, no puede haber mï¿œ de un precio a una misma fecha
-- Para un mismo almacï¿œ, artï¿œulo y tarifa, no puede haber mï¿œ de una oferta precio a una misma fecha
-- Sï¿œque se permite que haya solapamiento entre la tarifa normal y una oferta. Prevalece siempre la oferta.

--DROP TRIGGER restriccionestarifatrigger ON cuenta CASCADE;
--DROP FUNCTION restriccionestarifa();

CREATE FUNCTION restriccionestarifa () RETURNS "trigger"
AS '
DECLARE
	cont INTEGER;
BEGIN

RAISE NOTICE '' IDTARIFA = % '',NEW.idtarifa;
	 SELECT count(*) INTO cont FROM tarifa 
		WHERE tarifa.idtipo_tarifa = NEW.idtipo_tarifa AND tarifa.idarticulo = NEW.idarticulo AND tarifa.idalmacen = NEW.idalmacen AND tarifa.esofertatarifa = NEW.esofertatarifa AND
			tarifa.idtarifa != NEW.idtarifa AND tarifa.finiciotarifa <= NEW.finiciotarifa AND tarifa.ffintarifa >= NEW.finiciotarifa;
				if (NOT(cont ISNULL) AND cont > 0) THEN
 					RAISE EXCEPTION '' Solapamiento de fechas en fecha inicio '';
				END IF;
	RAISE NOTICE '' CONTADOR = % '', cont;

 	SELECT count(*) INTO cont FROM tarifa 
		WHERE tarifa.idtipo_tarifa = NEW.idtipo_tarifa AND tarifa.idarticulo = NEW.idarticulo AND tarifa.idalmacen = NEW.idalmacen AND tarifa.esofertatarifa = NEW.esofertatarifa AND
			tarifa.idtarifa != NEW.idtarifa AND tarifa.finiciotarifa <= NEW.ffintarifa AND tarifa.ffintarifa >= NEW.ffintarifa;
				if (NOT(cont ISNULL) AND cont > 0) THEN
 					RAISE EXCEPTION '' Solapamiento de fechas en fecha fin '';
				END IF;
	RAISE NOTICE '' CONTADOR = % '', cont;

        RETURN NEW;
END;
' LANGUAGE plpgsql;


CREATE TRIGGER restriccionestarifatrigger
    BEFORE INSERT OR UPDATE ON tarifa
    FOR EACH ROW
    EXECUTE PROCEDURE restriccionestarifa();

CREATE TABLE precio_compra (
	idprecio_compra serial PRIMARY KEY,
	idarticulo integer NOT NULL REFERENCES articulo(idarticulo),
	iddivision integer REFERENCES division(iddivision),
	idalmacen integer REFERENCES almacen(idalmacen),
	fechapreciocompra date,
	valorpreciocompra numeric(13, 4) NOT NULL
);


CREATE TABLE codigobarras (
	idcodigobarras serial PRIMARY KEY,
	idarticulo integer NOT NULL REFERENCES articulo(idarticulo),
	ean14codigobarras numeric(14, 0) NOT NULL UNIQUE,
	unixcajacodigobarras numeric(4, 0),
	cajxpaletcodigobarras numeric(4, 0),
	unidadcodigobarras character(1)
);

-- FUNCIONES VARIAS DE SOPORTE.

CREATE OR REPLACE FUNCTION ivaarticulo(integer) RETURNS numeric(12,2)
AS'
DECLARE
	idarticulo ALIAS FOR $1;
	as RECORD;
BEGIN
	SELECT INTO AS * FROM tipo_iva, tasa_iva, articulo WHERE tasa_iva.idtipo_iva = tipo_iva.idtipo_iva AND tipo_iva.idtipo_iva = articulo.idtipo_iva AND articulo.idarticulo = idarticulo ORDER BY fechatasa_iva;
	IF FOUND THEN
		RETURN as.porcentasa_iva;
	END IF;
	RETURN 0.0;
END;
' LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION pvparticulo(integer) RETURNS numeric(12,2)
AS'
DECLARE
	idarticulo ALIAS FOR $1;
	as RECORD;
BEGIN
	SELECT INTO AS pvparticulo FROM  articulo WHERE articulo.idarticulo = idarticulo;
	IF FOUND THEN
		RETURN as.pvparticulo;
	END IF;
	RETURN 0.0;
END;
' LANGUAGE plpgsql;


-- Any: Any en que s'efectua la comanda.
-- Numero: Nmero de comanda (comenï¿œnt de 1 cada any).
-- Descripcio: Breu descripciï¿œo comentari opcional.
-- Data: Data d'emisiï¿œde la comanda.
CREATE TABLE pedidoproveedor (
   idpedidoproveedor serial PRIMARY KEY,
   numpedidoproveedor integer UNIQUE NOT NULL,
   fechapedidoproveedor date,
   refpedidoproveedor character varying(12) NOT NULL,   
   descpedidoproveedor character varying(500),
   comentpedidoproveedor character varying(3000),
   contactpedidoproveedor character varying(90),
   telpedidoproveedor character varying(20),   
   procesadopedidoproveedor boolean DEFAULT FALSE,   
   idproveedor integer NOT NULL REFERENCES proveedor(idproveedor),
   idforma_pago integer REFERENCES forma_pago(idforma_pago),    
   idalmacen integer NOT NULL REFERENCES almacen(idalmacen),
   idtrabajador integer REFERENCES trabajador(idtrabajador)   
);

CREATE FUNCTION restriccionespedidoproveedor () RETURNS "trigger"
AS '
DECLARE
asd RECORD;
BEGIN
        IF NEW.numpedidoproveedor IS NULL THEN
                SELECT INTO asd max(numpedidoproveedor) AS m FROM pedidoproveedor;
		IF asd.m IS NOT NULL THEN
			NEW.numpedidoproveedor := asd.m + 1;
		ELSE
			NEW.numpedidoproveedor := 1;
		END IF;
        END IF;
	IF NEW.refpedidoproveedor IS NULL OR NEW.refpedidoproveedor = '''' THEN
		SELECT INTO asd crearef() AS m;
		IF FOUND THEN
			NEW.refpedidoproveedor := asd.m;
		END IF;
	END IF;
        RETURN NEW;
END;
' LANGUAGE plpgsql;


CREATE TRIGGER restriccionespedidoproveedortrigger
    BEFORE INSERT OR UPDATE ON pedidoproveedor
    FOR EACH ROW
    EXECUTE PROCEDURE restriccionespedidoproveedor();


-- Descuento de pedidocliente.
-- Numero
--Concepte: Descripciï¿œdel motiu de descompte.
--Proporcio: Percentatge a descomptar.
-- Descompte de pressupost a clients.
CREATE TABLE dpedidoproveedor (
   iddpedidoproveedor serial PRIMARY KEY,
   conceptdpedidoproveedor character varying(2000),
   proporciondpedidoproveedor numeric(12,2),
   idpedidoproveedor integer NOT NULL REFERENCES pedidoproveedor(idpedidoproveedor)
   -- Falta poner el lugar donde se aplica el descuento, antes de la factura o despuï¿œ de ï¿œta.
);    
    
-- Linea de pedido
-- Numero: Nmero de lï¿œia.
-- Descripcio: Descripcio de l'article.
-- Quantitat
-- PVD
-- Previsiï¿œ Data prevista de recepciï¿œ
CREATE TABLE lpedidoproveedor (
   numlpedidoproveedor serial PRIMARY KEY,
   desclpedidoproveedor character varying(150),
   cantlpedidoproveedor numeric(12,2),
   pvplpedidoproveedor numeric(12,2),
   prevlpedidoproveedor date,
   ivalpedidoproveedor numeric(12,2),
   descuentolpedidoproveedor numeric(12,2),   
   idpedidoproveedor integer NOT NULL REFERENCES pedidoproveedor(idpedidoproveedor),
   puntlpedidoproveedor boolean DEFAULT FALSE,
   idarticulo integer REFERENCES articulo(idarticulo)
);


-- Calculo de totales para presupuestos.
CREATE OR REPLACE FUNCTION calctotalpres(integer) RETURNS numeric(12,2)
AS '
DECLARE
idp ALIAS FOR $1;
total numeric(12,2);
res RECORD;
BEGIN
	total := 0;
	FOR  res IN SELECT cantlpresupuesto * pvplpresupuesto * (1 - descuentolpresupuesto/100) *(1+ ivalpresupuesto/100) AS subtotal1 FROM lpresupuesto WHERE idpresupuesto = idp LOOP
		total := total + res.subtotal1;
	END LOOP;
	FOR res IN SELECT proporciondpresupuesto FROM dpresupuesto WHERE idpresupuesto = idp LOOP
		total := total * (1 - res.proporciondpresupuesto/100);
	END LOOP;
	RETURN total;
END;
' language plpgsql;

-- Calculo de totales para presupuestos.
CREATE OR REPLACE FUNCTION calcbimppres(integer) RETURNS numeric(12,2)
AS '
DECLARE
idp ALIAS FOR $1;
total numeric(12,2);
res RECORD;
BEGIN
	total := 0;
	FOR  res IN SELECT cantlpresupuesto * pvplpresupuesto * (1 - descuentolpresupuesto/100) AS subtotal1 FROM lpresupuesto WHERE idpresupuesto = idp LOOP
		total := total + res.subtotal1;
	END LOOP;
	FOR res IN SELECT proporciondpresupuesto FROM dpresupuesto WHERE idpresupuesto = idp LOOP
		total := total * (1 - res.proporciondpresupuesto/100);
	END LOOP;
	RETURN total;
END;
' language plpgsql;

-- Calculo de totales para presupuestos.
CREATE OR REPLACE FUNCTION calcimpuestospres(integer) RETURNS numeric(12,2)
AS '
DECLARE
idp ALIAS FOR $1;
total numeric(12,2);
res RECORD;
BEGIN
	total := 0;
	FOR  res IN SELECT cantlpresupuesto * pvplpresupuesto * (1 - descuentolpresupuesto/100) * (ivalpresupuesto/100) AS subtotal1 FROM lpresupuesto WHERE idpresupuesto = idp LOOP
		total := total + res.subtotal1;
	END LOOP;
	FOR res IN SELECT proporciondpresupuesto FROM dpresupuesto WHERE idpresupuesto = idp LOOP
		total := total * (1 - res.proporciondpresupuesto/100);
	END LOOP;
	RETURN total;
END;
' language plpgsql;



-- CÃ¡lculo de totales para pedido cliente.
CREATE OR REPLACE FUNCTION calctotalpedcli(integer) RETURNS numeric(12,2)
AS '
DECLARE
idp ALIAS FOR $1;
total numeric(12,2);
res RECORD;
BEGIN
	total := 0;
	FOR  res IN SELECT cantlpedidocliente * pvplpedidocliente * (1 - descuentolpedidocliente/100) *(1+ ivalpedidocliente/100) AS subtotal1 FROM lpedidocliente WHERE idpedidocliente = idp LOOP
		total := total + res.subtotal1;
	END LOOP;
	FOR res IN SELECT proporciondpedidocliente FROM dpedidocliente WHERE idpedidocliente = idp LOOP
		total := total * (1 - res.proporciondpedidocliente/100);
	END LOOP;
	RETURN total;
END;
' language plpgsql;


-- CÃ¡lculo de totales para pedido cliente.
CREATE OR REPLACE FUNCTION calcbimppedcli(integer) RETURNS numeric(12,2)
AS '
DECLARE
idp ALIAS FOR $1;
total numeric(12,2);
res RECORD;
BEGIN
	total := 0;
	FOR  res IN SELECT cantlpedidocliente * pvplpedidocliente * (1 - descuentolpedidocliente/100) AS subtotal1 FROM lpedidocliente WHERE idpedidocliente = idp LOOP
		total := total + res.subtotal1;
	END LOOP;
	FOR res IN SELECT proporciondpedidocliente FROM dpedidocliente WHERE idpedidocliente = idp LOOP
		total := total * (1 - res.proporciondpedidocliente/100);
	END LOOP;
	RETURN total;
END;
' language plpgsql;

-- CÃ¡lculo de totales para pedido cliente.
CREATE OR REPLACE FUNCTION calcimpuestospedcli(integer) RETURNS numeric(12,2)
AS '
DECLARE
idp ALIAS FOR $1;
total numeric(12,2);
res RECORD;
BEGIN
	total := 0;
	FOR  res IN SELECT cantlpedidocliente * pvplpedidocliente * (1 - descuentolpedidocliente/100) *( ivalpedidocliente/100) AS subtotal1 FROM lpedidocliente WHERE idpedidocliente = idp LOOP
		total := total + res.subtotal1;
	END LOOP;
	FOR res IN SELECT proporciondpedidocliente FROM dpedidocliente WHERE idpedidocliente = idp LOOP
		total := total * (1 - res.proporciondpedidocliente/100);
	END LOOP;
	RETURN total;
END;
' language plpgsql;



-- CÃ¡lculo de totales para albaranes.
CREATE OR REPLACE FUNCTION calctotalalbaran(integer) RETURNS numeric(12,2)
AS '
DECLARE
idp ALIAS FOR $1;
total numeric(12,2);
res RECORD;
BEGIN
	total := 0;
	FOR  res IN SELECT cantlalbaran * pvplalbaran * (1 - descontlalbaran/100) *(1+ ivalalbaran/100) AS subtotal1 FROM lalbaran WHERE idalbaran = idp LOOP
		total := total + res.subtotal1;
	END LOOP;
	FOR res IN SELECT proporciondalbaran FROM dalbaran WHERE idalbaran = idp LOOP
		total := total * (1 - res.proporciondalbaran/100);
	END LOOP;
	RETURN total;
END;
' language plpgsql;

-- CÃ¡lculo de totales para albaranes.
CREATE OR REPLACE FUNCTION calcbimpalbaran(integer) RETURNS numeric(12,2)
AS '
DECLARE
idp ALIAS FOR $1;
total numeric(12,2);
res RECORD;
BEGIN
	total := 0;
	FOR  res IN SELECT cantlalbaran * pvplalbaran * (1 - descontlalbaran/100) AS subtotal1 FROM lalbaran WHERE idalbaran = idp LOOP
		total := total + res.subtotal1;
	END LOOP;
	FOR res IN SELECT proporciondalbaran FROM dalbaran WHERE idalbaran = idp LOOP
		total := total * (1 - res.proporciondalbaran/100);
	END LOOP;
	RETURN total;
END;
' language plpgsql;

-- CÃ¡lculo de totales para albaranes.
CREATE OR REPLACE FUNCTION calcimpuestosalbaran(integer) RETURNS numeric(12,2)
AS '
DECLARE
idp ALIAS FOR $1;
total numeric(12,2);
res RECORD;
BEGIN
	total := 0;
	FOR  res IN SELECT cantlalbaran * pvplalbaran * (1 - descontlalbaran/100)*(ivalalbaran/100) AS subtotal1 FROM lalbaran WHERE idalbaran = idp LOOP
		total := total + res.subtotal1;
	END LOOP;
	FOR res IN SELECT proporciondalbaran FROM dalbaran WHERE idalbaran = idp LOOP
		total := total * (1 - res.proporciondalbaran/100);
	END LOOP;
	RETURN total;
END;
' language plpgsql;


-- CÃ¡lculo de totales para facturas
CREATE OR REPLACE FUNCTION calctotalfactura(integer) RETURNS numeric(12,2)
AS '
DECLARE
idp ALIAS FOR $1;
total numeric(12,2);
res RECORD;
BEGIN
	total := 0;
	FOR  res IN SELECT cantlfactura * pvplfactura * (1 - descuentolfactura/100) *(1+ ivalfactura/100) AS subtotal1 FROM lfactura WHERE idfactura = idp LOOP
		total := total + res.subtotal1;
	END LOOP;
	FOR res IN SELECT proporciondfactura FROM dfactura WHERE idfactura = idp LOOP
		total := total * (1 - res.proporciondfactura/100);
	END LOOP;
	RETURN total;
END;
' language plpgsql;

-- CÃ¡lculo de totales para facturas
CREATE OR REPLACE FUNCTION calcbimpfactura(integer) RETURNS numeric(12,2)
AS '
DECLARE
idp ALIAS FOR $1;
total numeric(12,2);
res RECORD;
BEGIN
	total := 0;
	FOR  res IN SELECT cantlfactura * pvplfactura * (1 - descuentolfactura/100) AS subtotal1 FROM lfactura WHERE idfactura = idp LOOP
		total := total + res.subtotal1;
	END LOOP;
	FOR res IN SELECT proporciondfactura FROM dfactura WHERE idfactura = idp LOOP
		total := total * (1 - res.proporciondfactura/100);
	END LOOP;
	RETURN total;
END;
' language plpgsql;

-- CÃ¡lculo de totales para facturas
CREATE OR REPLACE FUNCTION calcimpuestosfactura(integer) RETURNS numeric(12,2)
AS '
DECLARE
idp ALIAS FOR $1;
total numeric(12,2);
res RECORD;
BEGIN
	total := 0;
	FOR  res IN SELECT cantlfactura * pvplfactura * (1 - descuentolfactura/100) *(ivalfactura/100) AS subtotal1 FROM lfactura WHERE idfactura = idp LOOP
		total := total + res.subtotal1;
	END LOOP;
	FOR res IN SELECT proporciondfactura FROM dfactura WHERE idfactura = idp LOOP
		total := total * (1 - res.proporciondfactura/100);
	END LOOP;
	RETURN total;
END;
' language plpgsql;

-- CÃ¡lculo de totales para pedido proveedor
CREATE OR REPLACE FUNCTION calctotalpedpro(integer) RETURNS numeric(12,2)
AS '
DECLARE
idp ALIAS FOR $1;
total numeric(12,2);
res RECORD;
BEGIN
	total := 0;
	FOR  res IN SELECT cantlpedidoproveedor * pvplpedidoproveedor * (1 - descuentolpedidoproveedor/100) *(1+ ivalpedidoproveedor/100) AS subtotal1 FROM lpedidoproveedor WHERE idpedidoproveedor = idp LOOP
		total := total + res.subtotal1;
	END LOOP;
	FOR res IN SELECT proporciondpedidoproveedor FROM dpedidoproveedor WHERE idpedidoproveedor = idp LOOP
		total := total * (1 - res.proporciondpedidoproveedor/100);
	END LOOP;
	RETURN total;
END;
' language plpgsql;

CREATE OR REPLACE FUNCTION calcbimppedpro(integer) RETURNS numeric(12,2)
AS '
DECLARE
idp ALIAS FOR $1;
total numeric(12,2);
res RECORD;
BEGIN
	total := 0;
	FOR  res IN SELECT cantlpedidoproveedor * pvplpedidoproveedor * (1 - descuentolpedidoproveedor/100) AS subtotal1 FROM lpedidoproveedor WHERE idpedidoproveedor = idp LOOP
		total := total + res.subtotal1;
	END LOOP;
	FOR res IN SELECT proporciondpedidoproveedor FROM dpedidoproveedor WHERE idpedidoproveedor = idp LOOP
		total := total * (1 - res.proporciondpedidoproveedor/100);
	END LOOP;
	RETURN total;
END;
' language plpgsql;


CREATE OR REPLACE FUNCTION calcimpuestospedpro(integer) RETURNS numeric(12,2)
AS '
DECLARE
idp ALIAS FOR $1;
total numeric(12,2);
res RECORD;
BEGIN
	total := 0;
	FOR  res IN SELECT cantlpedidoproveedor * pvplpedidoproveedor * (1 - descuentolpedidoproveedor/100) *( ivalpedidoproveedor/100) AS subtotal1 FROM lpedidoproveedor WHERE idpedidoproveedor = idp LOOP
		total := total + res.subtotal1;
	END LOOP;
	FOR res IN SELECT proporciondpedidoproveedor FROM dpedidoproveedor WHERE idpedidoproveedor = idp LOOP
		total := total * (1 - res.proporciondpedidoproveedor/100);
	END LOOP;
	RETURN total;
END;
' language plpgsql;

-- CÃ¡lculo de totales para albaaran proveedor
CREATE OR REPLACE FUNCTION calctotalalbpro(integer) RETURNS numeric(12,2)
AS '
DECLARE
idp ALIAS FOR $1;
total numeric(12,2);
res RECORD;
BEGIN
	total := 0;
	FOR  res IN SELECT cantlalbaranp * pvplalbaranp * (1 - descontlalbaranp/100) *(1+ ivalalbaranp/100) AS subtotal1 FROM lalbaranp WHERE idalbaranp = idp LOOP
		total := total + res.subtotal1;
	END LOOP;
	FOR res IN SELECT proporciondalbaranp FROM dalbaranp WHERE idalbaranp = idp LOOP
		total := total * (1 - res.proporciondalbaranp/100);
	END LOOP;
	RETURN total;
END;
' language plpgsql;

CREATE OR REPLACE FUNCTION calcbimpalbpro(integer) RETURNS numeric(12,2)
AS '
DECLARE
idp ALIAS FOR $1;
total numeric(12,2);
res RECORD;
BEGIN
	total := 0;
	FOR  res IN SELECT cantlalbaranp * pvplalbaranp * (1 - descontlalbaranp/100) AS subtotal1 FROM lalbaranp WHERE idalbaranp = idp LOOP
		total := total + res.subtotal1;
	END LOOP;
	FOR res IN SELECT proporciondalbaranp FROM dalbaranp WHERE idalbaranp = idp LOOP
		total := total * (1 - res.proporciondalbaranp/100);
	END LOOP;
	RETURN total;
END;
' language plpgsql;
\echo "CÃ¡lculo de totales para albaranes de proveedor"

CREATE OR REPLACE FUNCTION calcimpuestosalbpro(integer) RETURNS numeric(12,2)
AS '
DECLARE
idp ALIAS FOR $1;
total numeric(12,2);
res RECORD;
BEGIN
	total := 0;
	FOR  res IN SELECT cantlalbaranp * pvplalbaranp * (1 - descontlalbaranp/100) *(ivalalbaranp/100) AS subtotal1 FROM lalbaranp WHERE idalbaranp = idp LOOP
		total := total + res.subtotal1;
	END LOOP;
	FOR res IN SELECT proporciondalbaranp FROM dalbaranp WHERE idalbaranp = idp LOOP
		total := total * (1 - res.proporciondalbaranp/100);
	END LOOP;
	RETURN total;
END;
' language plpgsql;

-- CÃ¡lculo de totales para factura proveedor
CREATE OR REPLACE FUNCTION calctotalfacpro(integer) RETURNS numeric(12,2)
AS '
DECLARE
idp ALIAS FOR $1;
total numeric(12,2);
res RECORD;
BEGIN
	total := 0;
	FOR  res IN SELECT cantlfacturap * pvplfacturap * (1 - descuentolfacturap/100) *(1+ ivalfacturap/100) AS subtotal1 FROM lfacturap WHERE idfacturap = idp LOOP
		total := total + res.subtotal1;
	END LOOP;
	FOR res IN SELECT proporciondfacturap FROM dfacturap WHERE idfacturap = idp LOOP
		total := total * (1 - res.proporciondfacturap/100);
	END LOOP;
	RETURN total;
END;
' language plpgsql;


-- CÃ¡lculo de totales para factura proveedor
CREATE OR REPLACE FUNCTION calcbimpfacpro(integer) RETURNS numeric(12,2)
AS '
DECLARE
idp ALIAS FOR $1;
total numeric(12,2);
res RECORD;
BEGIN
	total := 0;
	FOR  res IN SELECT cantlfacturap * pvplfacturap * (1 - descuentolfacturap/100) AS subtotal1 FROM lfacturap WHERE idfacturap = idp LOOP
		total := total + res.subtotal1;
	END LOOP;
	FOR res IN SELECT proporciondfacturap FROM dfacturap WHERE idfacturap = idp LOOP
		total := total * (1 - res.proporciondfacturap/100);
	END LOOP;
	RETURN total;
END;
' language plpgsql;

-- CÃ¡lculo de totales para factura proveedor
CREATE OR REPLACE FUNCTION calcimpuestosfacpro(integer) RETURNS numeric(12,2)
AS '
DECLARE
idp ALIAS FOR $1;
total numeric(12,2);
res RECORD;
BEGIN
	total := 0;
	FOR  res IN SELECT cantlfacturap * pvplfacturap * (1 - descuentolfacturap/100) *(ivalfacturap/100) AS subtotal1 FROM lfacturap WHERE idfacturap = idp LOOP
		total := total + res.subtotal1;
	END LOOP;
	FOR res IN SELECT proporciondfacturap FROM dfacturap WHERE idfacturap = idp LOOP
		total := total * (1 - res.proporciondfacturap/100);
	END LOOP;
	RETURN total;
END;
' language plpgsql;

-- bulmafact_data.sql   ###########################################

#SET DATESTYLE TO European;

INSERT INTO configuracion (nombre, valor) VALUES ('CodCuenta', 'xxxxyyy');
INSERT INTO configuracion (nombre, valor) VALUES ('CIF', '--');
INSERT INTO configuracion (nombre, valor) VALUES ('TipoVia', '--');
INSERT INTO configuracion (nombre, valor) VALUES ('NombreVia', '--');
INSERT INTO configuracion (nombre, valor) VALUES ('NumeroVia', '--');
INSERT INTO configuracion (nombre, valor) VALUES ('Escalera', '--');
INSERT INTO configuracion (nombre, valor) VALUES ('Piso', '--');
INSERT INTO configuracion (nombre, valor) VALUES ('Puerta', '--');
INSERT INTO configuracion (nombre, valor) VALUES ('CodPostal', '--');
INSERT INTO configuracion (nombre, valor) VALUES ('Municipio', '--');
INSERT INTO configuracion (nombre, valor) VALUES ('Provincia', '--');
INSERT INTO configuracion (nombre, valor) VALUES ('Pais', '--');
INSERT INTO configuracion (nombre, valor) VALUES ('Tipo', 'BulmaFact');
INSERT INTO configuracion (nombre, valor) VALUES ('ProgramaContabilidad', 'BulmaCont');
INSERT INTO configuracion (nombre, valor) VALUES ('NombreEmpresa', 'Sin Definir');
INSERT INTO configuracion (nombre, valor) VALUES ('AlmacenDefecto', '100');


INSERT INTO forma_pago (descforma_pago, dias1tforma_pago, descuentoforma_pago) VALUES ('Contado', 1, 5);
INSERT INTO forma_pago (descforma_pago, dias1tforma_pago, descuentoforma_pago) VALUES ('Pagare 30 dÃ­as', 30, 0);
INSERT INTO forma_pago (descforma_pago, dias1tforma_pago, descuentoforma_pago) VALUES ('Pagare 60 dÃ­as', 60, 0);
INSERT INTO forma_pago (descforma_pago, dias1tforma_pago, descuentoforma_pago) VALUES ('TalÃ³n 15 dias', 15, 1);


INSERT INTO tipo_tarifa (codtipo_tarifa, desctipo_tarifa) VALUES('GENERAL', 'Tarifa General');

INSERT INTO almacen (codigoalmacen, nomalmacen, diralmacen, poblalmacen, cpalmacen, telalmacen, faxalmacen) VALUES (100, 'La Botica del Abuelo', 'CamÃ­ Vell de Bunyola', 'Palma de Mallorca', '07009', '971434343', '971434344');
INSERT INTO almacen (codigoalmacen, nomalmacen, diralmacen, poblalmacen, cpalmacen, telalmacen, faxalmacen) VALUES (200, 'Colmado de Mateo', 'Joan Maura', 'Palma de Mallorca', '07005', '971467911', '971776776');
INSERT INTO almacen (codigoalmacen, nomalmacen, diralmacen, poblalmacen, cpalmacen, telalmacen, faxalmacen) VALUES (300, 'AlmacÃ©n Norte', 'PolÃ­ono homogeneo', 'Alcudia', '07012', '971167911', '971111776');


INSERT INTO proveedor (nomproveedor, cifproveedor, cpproveedor) VALUES ('Tomeu', '45678098D', '07008');
INSERT INTO proveedor (nomproveedor, cifproveedor, cpproveedor) VALUES ('Cristina', '45679998D', '07008');
INSERT INTO proveedor (nomproveedor, cifproveedor, cpproveedor) VALUES ('Marco Aurelio', '45668998D', '07008');
INSERT INTO proveedor (nomproveedor, cifproveedor, cpproveedor) VALUES ('Torrijas', '45678995D', '07008');

INSERT INTO division (idproveedor, descdivision) VALUES (1, 'division 1 de mateu');
INSERT INTO division (idproveedor, descdivision) VALUES (1, 'division 2 de mateu');
INSERT INTO division (idproveedor, descdivision) VALUES (2, 'division 1 de cristina');
INSERT INTO division (idproveedor, descdivision) VALUES (2, 'division 2 de cristina');
INSERT INTO division (idproveedor, descdivision) VALUES (2, 'division 3 de cristina');
INSERT INTO division (idproveedor, descdivision) VALUES (4, 'division 1 de Torrijas');


INSERT INTO cliente (nomcliente, cifcliente, telcliente, poblcliente) VALUES('Jorge GutiÃ©rrez', '39881444W', '971998877', 'Palma de Mallorca');
INSERT INTO cliente (nomcliente, cifcliente, telcliente, poblcliente) VALUES('Carlos Santana', '43881555Z', '871998877', 'Campos');
INSERT INTO cliente (nomcliente, cifcliente, telcliente, poblcliente) VALUES('Dolores MartÃ­nez', '66881444E', '666998877', 'Muro');
INSERT INTO cliente (nomcliente, cifcliente, telcliente, poblcliente) VALUES('Pepe Infante', '55881444W', '9321998877', 'Barcelona');

INSERT INTO tipo_iva (desctipo_iva) VALUES('Exento');
INSERT INTO tipo_iva (desctipo_iva) VALUES('Normal');
INSERT INTO tasa_iva(idtipo_iva, porcentasa_iva, fechatasa_iva) VALUES(1, 0, '0001-01-01');
INSERT INTO tasa_iva(idtipo_iva, porcentasa_iva, fechatasa_iva) VALUES(2, 16.00, '0001-01-01');
INSERT INTO tasa_iva(idtipo_iva, porcentasa_iva, fechatasa_iva) VALUES(2, 17.00, '2005-01-01');

INSERT INTO familia(codigofamilia, nombrefamilia, padrefamilia) VALUES ('CO', 'Comestibles', NULL);
INSERT INTO familia(codigofamilia, nombrefamilia, padrefamilia) VALUES ('DR', 'Drogueria', NULL);
INSERT INTO familia(codigofamilia, nombrefamilia, padrefamilia) VALUES ('VE', 'Vehiculos', NULL);
INSERT INTO familia(codigofamilia, nombrefamilia, padrefamilia) VALUES ('LA', 'Lacteos', 1);
INSERT INTO familia(codigofamilia, nombrefamilia, padrefamilia) VALUES ('CA', 'Carnicos', 1);
INSERT INTO familia(codigofamilia, nombrefamilia, padrefamilia) VALUES ('CH', 'Charcuteria', 1);
INSERT INTO familia(codigofamilia, nombrefamilia, padrefamilia) VALUES ('PE', 'Pescaderia', 1);
INSERT INTO familia(codigofamilia, nombrefamilia, padrefamilia) VALUES ('PA', 'Panaderia', 1);
INSERT INTO familia(codigofamilia, nombrefamilia, padrefamilia) VALUES ('FU', 'Fruteria', 1);
INSERT INTO familia(codigofamilia, nombrefamilia, padrefamilia) VALUES ('BE', 'Bebidas', 1);
INSERT INTO familia(codigofamilia, nombrefamilia, padrefamilia) VALUES ('IN', 'Infusiones', 1);
\echo "Hemos insertado las familias"

INSERT INTO articulo (codarticulo, nomarticulo, obserarticulo, idtipo_iva, idfamilia) VALUES('1', 'Leche Entera', 'Brick leche entera 1 litro', 1, 4);
INSERT INTO articulo (codarticulo, nomarticulo, obserarticulo, idtipo_iva, idfamilia) VALUES('2', 'Natillas', 'Pack dos envases de natillas de vainilla', 2, 4);
INSERT INTO articulo (codarticulo, nomarticulo, obserarticulo, idtipo_iva, idfamilia) VALUES('3', 'Iogurt', 'Pack 4 unidades yogures sabores', 1, 5);
INSERT INTO articulo (codarticulo, nomarticulo, obserarticulo, idtipo_iva, idfamilia) VALUES('4', 'NestcafÃ©', 'Bote 400 gramos cafÃ© soluble natural', 1, 5);
\echo "Hemos insertado los articulos"

INSERT INTO pedido (numpedido, fechapedido, descpedido, iddivision, idalmacen) VALUES('P-1', '25/10/2004', 'Pedido semanal de carne y pescado', 1, 1);
INSERT INTO pedido (numpedido, fechapedido, descpedido, iddivision, idalmacen) VALUES('P-2', '30/10/2004', 'Pedido especial noche halloween', 2, 3);
INSERT INTO pedido (numpedido, fechapedido, descpedido, iddivision, idalmacen) VALUES('P-3', '02/11/2004', 'Frutos secos de temporada', 3, 2);
INSERT INTO pedido (numpedido, fechapedido, descpedido, iddivision, idalmacen) VALUES('P-4', '02/10/2004', 'Pedido semanal de lencerÃ­a', 6, 1);
\echo "Hemos insertado los pedidos"

INSERT INTO lpedido (desclpedido, cantlpedido, pvdlpedido, prevlpedido, idpedido, idarticulo) VALUES (' ', 10, 1.2, '30/10/2004', 1, 1);
INSERT INTO lpedido (desclpedido, cantlpedido, pvdlpedido, prevlpedido, idpedido, idarticulo) VALUES (' ', 100, 2.23, '02/11/2004', 1, 2);
INSERT INTO lpedido (desclpedido, cantlpedido, pvdlpedido, prevlpedido, idpedido, idarticulo) VALUES (' ', 15, 3.34, '30/10/2004', 1, 3);
INSERT INTO lpedido (desclpedido, cantlpedido, pvdlpedido, prevlpedido, idpedido, idarticulo) VALUES (' ', 34, 11.20, '05/11/2004', 2, 1);
INSERT INTO lpedido (desclpedido, cantlpedido, pvdlpedido, prevlpedido, idpedido, idarticulo) VALUES (' ', 45, 2.55, '05/11/2004', 2, 3);
INSERT INTO lpedido (desclpedido, cantlpedido, pvdlpedido, prevlpedido, idpedido, idarticulo) VALUES (' ', 1, 4.28, '10/11/2004', 2, 4);
INSERT INTO lpedido (desclpedido, cantlpedido, pvdlpedido, prevlpedido, idpedido, idarticulo) VALUES (' ', 34, 1.7, '31/12/2004', 3, 2);
INSERT INTO lpedido (desclpedido, cantlpedido, pvdlpedido, prevlpedido, idpedido, idarticulo) VALUES (' ', 11, 1.3, '30/12/2004', 3, 3);
INSERT INTO lpedido (desclpedido, cantlpedido, pvdlpedido, prevlpedido, idpedido, idarticulo) VALUES (' ', 28, 2.2, '30/12/2004', 3, 4);
INSERT INTO lpedido (desclpedido, cantlpedido, pvdlpedido, prevlpedido, idpedido, idarticulo) VALUES (' ', 15, 3.2, '15/11/2004', 4, 1);
INSERT INTO lpedido (desclpedido, cantlpedido, pvdlpedido, prevlpedido, idpedido, idarticulo) VALUES (' ', 10, 8.59, '10/11/2004', 4, 2);
INSERT INTO lpedido (desclpedido, cantlpedido, pvdlpedido, prevlpedido, idpedido, idarticulo) VALUES (' ', 6, 6.15, '25/11/2004', 4, 3);



INSERT INTO pedidocliente (numpedidocliente, fechapedidocliente, descpedidocliente, idcliente, idalmacen) VALUES(1, '25/10/2004', 'Pedido  carne y pescado', 1, 1);
INSERT INTO pedidocliente (numpedidocliente, fechapedidocliente, descpedidocliente, idcliente, idalmacen) VALUES(2, '30/10/2004', 'Pedido especial noche ', 2, 3);
INSERT INTO pedidocliente (numpedidocliente, fechapedidocliente, descpedidocliente, idcliente, idalmacen) VALUES(3, '02/11/2004', 'Frutos de temporada', 1, 2);
INSERT INTO pedidocliente (numpedidocliente, fechapedidocliente, descpedidocliente, idcliente, idalmacen) VALUES(4, '02/10/2004', 'Pedido de lencerÃ­a', 2, 1);
\echo "Hemos insertado los pedidos de cliente"



INSERT INTO presupuesto (numpresupuesto, fpresupuesto, contactpresupuesto, telpresupuesto, vencpresupuesto, comentpresupuesto, idusuari, idcliente, idalmacen, idforma_pago) VALUES (1, '30/11/2004', 'Primer Contacto', '971 32 32 78', '12/12/2004', 'Sin comentarios', 1, 1, 1,1);
INSERT INTO presupuesto (numpresupuesto, fpresupuesto, contactpresupuesto, telpresupuesto, vencpresupuesto, comentpresupuesto, idusuari, idcliente, idalmacen, idforma_pago) VALUES (2, '29/11/2004', 'Segundo Contacto', '91 454 45 30', '13/12/2004', 'Sin comentarios', 1, 1, 1,1);
INSERT INTO presupuesto (numpresupuesto, fpresupuesto, contactpresupuesto, telpresupuesto, vencpresupuesto, comentpresupuesto, idusuari, idcliente, idalmacen, idforma_pago) VALUES (3, '10/11/2004', 'Tercer Contacto', '971 29 06 29', '14/12/2004', 'Sin comentarios', 1, 2, 1,1);


INSERT INTO serie_factura (codigoserie_factura, descserie_factura) VALUES ('DD', 'Serie de ejemplo');
INSERT INTO serie_factura (codigoserie_factura, descserie_factura) VALUES ('REC', 'Facturas Rectificativas');


INSERT INTO factura (codigoserie_factura, numfactura, ffactura, contactfactura, telfactura, comentfactura, idusuari, idcliente, idalmacen) VALUES ('DD', 1, '30/11/2004', 'Primer Contacto', '971 32 32 78', 'Sin comentarios', 1, 1, 1);
INSERT INTO factura (codigoserie_factura,numfactura, ffactura, contactfactura, telfactura, comentfactura, idusuari, idcliente, idalmacen) VALUES ('DD', 2, '29/11/2004', 'Segundo Contacto', '91 454 45 30', 'Sin comentarios', 1, 1, 1);
INSERT INTO factura (codigoserie_factura,numfactura, ffactura, contactfactura, telfactura, comentfactura, idusuari, idcliente, idalmacen) VALUES ('REC', 3, '10/11/2004', 'Tercer Contacto', '971 29 06 29',  'Sin comentarios', 1, 2, 1);


INSERT INTO facturap (numfacturap, ffacturap, contactfacturap, telfacturap, comentfacturap, idusuari, idproveedor) VALUES ( 1, '30/11/2004', 'Primer Contacto', '971 32 32 78', 'Sin comentarios', 1, 1);
INSERT INTO facturap (numfacturap, ffacturap, contactfacturap, telfacturap, comentfacturap, idusuari, idproveedor) VALUES ( 2, '29/11/2004', 'Segundo Contacto', '91 454 45 30', 'Sin comentarios', 1, 1);
INSERT INTO facturap (numfacturap, ffacturap, contactfacturap, telfacturap, comentfacturap, idusuari, idproveedor) VALUES ( 3, '10/11/2004', 'Tercer Contacto', '971 29 06 29',  'Sin comentarios', 1, 2);




INSERT INTO suministra (idarticulo, idproveedor) VALUES (1, 1);
INSERT INTO suministra (idarticulo, idproveedor) VALUES (2, 1);
INSERT INTO suministra (idarticulo, idproveedor) VALUES (3, 2);
INSERT INTO suministra (idarticulo, idproveedor) VALUES (4, 2);
INSERT INTO suministra (idarticulo, idproveedor) VALUES (2, 3);
INSERT INTO suministra (idarticulo, idproveedor) VALUES (3, 3);
INSERT INTO suministra (idarticulo, idproveedor) VALUES (4, 1);




INSERT INTO albaran (numalbaran, fechaalbaran, idtrabajador, idcliente, idforma_pago, idalmacen, refalbaran) VALUES (1, '01/01/2005', NULL, 1, 1, 1,'R1');
INSERT INTO albaran (numalbaran, fechaalbaran, idtrabajador, idcliente, idforma_pago, idalmacen, refalbaran) VALUES (2, '02/01/2005', NULL, 1, 2, 1,'R2');
INSERT INTO albaran (numalbaran, fechaalbaran, idtrabajador, idcliente, idforma_pago, idalmacen, refalbaran) VALUES (3, '03/01/2005', NULL, 2, 3, 1,'R3');
INSERT INTO albaran (numalbaran, fechaalbaran, idtrabajador, idcliente, idforma_pago, idalmacen, refalbaran) VALUES (4, '01/01/2005', NULL, 2, 4, 1,'R4');
INSERT INTO albaran (numalbaran, fechaalbaran, idtrabajador, idcliente, idforma_pago, idalmacen, refalbaran) VALUES (5, '02/01/2005', NULL, 3, 2, 1,'R5');
INSERT INTO albaran (numalbaran, fechaalbaran, idtrabajador, idcliente, idforma_pago, idalmacen, refalbaran) VALUES (6, '03/01/2005', NULL, 4, 1, 1,'R6');


INSERT INTO albaranp (numalbaranp, fechaalbaranp, idtrabajador, idproveedor, idforma_pago, idalmacen, refalbaranp) VALUES (1, '01/01/2005', NULL, 1, 1, 1,'RP1');
INSERT INTO albaranp (numalbaranp, fechaalbaranp, idtrabajador, idproveedor, idforma_pago, idalmacen, refalbaranp) VALUES (2, '02/01/2005', NULL, 1, 2, 1,'RP2');
INSERT INTO albaranp (numalbaranp, fechaalbaranp, idtrabajador, idproveedor, idforma_pago, idalmacen, refalbaranp) VALUES (3, '03/01/2005', NULL, 2, 3, 1,'RP3');
INSERT INTO albaranp (numalbaranp, fechaalbaranp, idtrabajador, idproveedor, idforma_pago, idalmacen, refalbaranp) VALUES (4, '01/01/2005', NULL, 2, 4, 1,'RP4');
INSERT INTO albaranp (numalbaranp, fechaalbaranp, idtrabajador, idproveedor, idforma_pago, idalmacen, refalbaranp) VALUES (5, '02/01/2005', NULL, 3, 2, 1,'RP5');
INSERT INTO albaranp (numalbaranp, fechaalbaranp, idtrabajador, idproveedor, idforma_pago, idalmacen, refalbaranp) VALUES (6, '03/01/2005', NULL, 4, 1, 1,'RP6');
